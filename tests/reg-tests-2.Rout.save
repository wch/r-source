
R : Copyright 2003, The R Development Core Team
Version 1.7.0 Under development (unstable) (2003-04-08)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type `license()' or `licence()' for distribution details.

R is a collaborative project with many contributors.
Type `contributors()' for more information.

Type `demo()' for some demos, `help()' for on-line help, or
`help.start()' for a HTML browser interface to help.
Type `q()' to quit R.

> ### Regression tests for which the printed output is the issue
> 
> postscript("reg-tests-2.ps")
> RNGversion("1.6.2")
> 
> ### moved from various .Rd files
> ## abbreviate
> data(state)
> for(m in 1:5) {
+   cat("\n",m,":\n")
+   print(as.vector(abbreviate(state.name, minl=m)))
+ }

 1 :
 [1] "Alb"  "Als"  "Arz"  "Ark"  "Clf"  "Clr"  "Cn"   "D"    "F"    "G"   
[11] "H"    "Id"   "Il"   "In"   "Iw"   "Kns"  "Knt"  "L"    "Man"  "Mr"  
[21] "Mssc" "Mc"   "Mnn"  "Msss" "Mssr" "Mnt"  "Nb"   "Nv"   "NH"   "NJ"  
[31] "NM"   "NY"   "NC"   "ND"   "Oh"   "Ok"   "Or"   "P"    "RI"   "SC"  
[41] "SD"   "Tn"   "Tx"   "U"    "Vrm"  "Vrg"  "Wsh"  "WV"   "Wsc"  "Wy"  

 2 :
 [1] "Alb"  "Als"  "Arz"  "Ark"  "Clf"  "Clr"  "Cn"   "Dl"   "Fl"   "Gr"  
[11] "Hw"   "Id"   "Il"   "In"   "Iw"   "Kns"  "Knt"  "Ls"   "Man"  "Mr"  
[21] "Mssc" "Mc"   "Mnn"  "Msss" "Mssr" "Mnt"  "Nb"   "Nv"   "NH"   "NJ"  
[31] "NM"   "NY"   "NC"   "ND"   "Oh"   "Ok"   "Or"   "Pn"   "RI"   "SC"  
[41] "SD"   "Tn"   "Tx"   "Ut"   "Vrm"  "Vrg"  "Wsh"  "WV"   "Wsc"  "Wy"  

 3 :
 [1] "Alb"  "Als"  "Arz"  "Ark"  "Clf"  "Clr"  "Cnn"  "Dlw"  "Flr"  "Grg" 
[11] "Haw"  "Idh"  "Ill"  "Ind"  "Iow"  "Kns"  "Knt"  "Lsn"  "Man"  "Mry" 
[21] "Mssc" "Mch"  "Mnn"  "Msss" "Mssr" "Mnt"  "Nbr"  "Nvd"  "NwH"  "NwJ" 
[31] "NwM"  "NwY"  "NrC"  "NrD"  "Ohi"  "Okl"  "Org"  "Pnn"  "RhI"  "StC" 
[41] "StD"  "Tnn"  "Txs"  "Uth"  "Vrm"  "Vrg"  "Wsh"  "WsV"  "Wsc"  "Wym" 

 4 :
 [1] "Albm" "Alsk" "Arzn" "Arkn" "Clfr" "Clrd" "Cnnc" "Dlwr" "Flrd" "Gerg"
[11] "Hawa" "Idah" "Illn" "Indn" "Iowa" "Knss" "Kntc" "Losn" "Main" "Mryl"
[21] "Mssc" "Mchg" "Mnns" "Msss" "Mssr" "Mntn" "Nbrs" "Nevd" "NwHm" "NwJr"
[31] "NwMx" "NwYr" "NrtC" "NrtD" "Ohio" "Oklh" "Orgn" "Pnns" "RhdI" "SthC"
[41] "SthD" "Tnns" "Texs" "Utah" "Vrmn" "Vrgn" "Wshn" "WstV" "Wscn" "Wymn"

 5 :
 [1] "Alabm" "Alask" "Arizn" "Arkns" "Clfrn" "Colrd" "Cnnct" "Delwr" "Flord"
[10] "Georg" "Hawai" "Idaho" "Illns" "Indin" "Iowa"  "Kanss" "Kntck" "Lousn"
[19] "Maine" "Mryln" "Mssch" "Mchgn" "Mnnst" "Mssss" "Missr" "Montn" "Nbrsk"
[28] "Nevad" "NwHmp" "NwJrs" "NwMxc" "NwYrk" "NrthC" "NrthD" "Ohio"  "Oklhm"
[37] "Oregn" "Pnnsy" "RhdIs" "SthCr" "SthDk" "Tnnss" "Texas" "Utah"  "Vrmnt"
[46] "Virgn" "Wshng" "WstVr" "Wscns" "Wymng"
> 
> ## apply
> x <- cbind(x1 = 3, x2 = c(4:1, 2:5))
> dimnames(x)[[1]] <- letters[1:8]
> apply(x,  2, summary) # 6 x n matrix
        x1 x2
Min.     3  1
1st Qu.  3  2
Median   3  3
Mean     3  3
3rd Qu.  3  4
Max.     3  5
> apply(x,  1, quantile)# 5 x n matrix
        a b    c   d    e f    g   h
0%   3.00 3 2.00 1.0 2.00 3 3.00 3.0
25%  3.25 3 2.25 1.5 2.25 3 3.25 3.5
50%  3.50 3 2.50 2.0 2.50 3 3.50 4.0
75%  3.75 3 2.75 2.5 2.75 3 3.75 4.5
100% 4.00 3 3.00 3.0 3.00 3 4.00 5.0
> 
> d.arr <- 2:5
> arr <- array(1:prod(d.arr), d.arr,
+          list(NULL,letters[1:d.arr[2]],NULL,paste("V",4+1:d.arr[4],sep="")))
> aa <- array(1:20,c(2,2,5))
> str(apply(aa[FALSE,,,drop=FALSE], 1, dim))# empty integer, `incorrect' dim.
 int[, 0 ] 
> stopifnot(
+        apply(arr, 1:2, sum) == t(apply(arr, 2:1, sum)),
+        aa == apply(aa,2:3,function(x) x),
+        all.equal(apply(apply(aa,2:3, sum),2,sum),
+                  10+16*0:4, tol=4*.Machine$double.eps)
+ )
> marg <- list(1:2, 2:3, c(2,4), c(1,3), 2:4, 1:3, 1:4)
> for(m in marg) print(apply(arr, print(m), sum))
[1] 1 2
        a    b    c
[1,] 1160 1200 1240
[2,] 1180 1220 1260
[1] 2 3
  [,1] [,2] [,3] [,4]
a  495  555  615  675
b  515  575  635  695
c  535  595  655  715
[1] 2 4
   V5  V6  V7  V8  V9
a  84 276 468 660 852
b 100 292 484 676 868
c 116 308 500 692 884
[1] 1 3
     [,1] [,2] [,3] [,4]
[1,]  765  855  945 1035
[2,]  780  870  960 1050
[1] 2 3 4
, , V5

  [,1] [,2] [,3] [,4]
a    3   15   27   39
b    7   19   31   43
c   11   23   35   47

, , V6

  [,1] [,2] [,3] [,4]
a   51   63   75   87
b   55   67   79   91
c   59   71   83   95

, , V7

  [,1] [,2] [,3] [,4]
a   99  111  123  135
b  103  115  127  139
c  107  119  131  143

, , V8

  [,1] [,2] [,3] [,4]
a  147  159  171  183
b  151  163  175  187
c  155  167  179  191

, , V9

  [,1] [,2] [,3] [,4]
a  195  207  219  231
b  199  211  223  235
c  203  215  227  239

[1] 1 2 3
, , 1

       a   b   c
[1,] 245 255 265
[2,] 250 260 270

, , 2

       a   b   c
[1,] 275 285 295
[2,] 280 290 300

, , 3

       a   b   c
[1,] 305 315 325
[2,] 310 320 330

, , 4

       a   b   c
[1,] 335 345 355
[2,] 340 350 360

[1] 1 2 3 4
, , 1, V5

     a b c
[1,] 1 3 5
[2,] 2 4 6

, , 2, V5

     a  b  c
[1,] 7  9 11
[2,] 8 10 12

, , 3, V5

      a  b  c
[1,] 13 15 17
[2,] 14 16 18

, , 4, V5

      a  b  c
[1,] 19 21 23
[2,] 20 22 24

, , 1, V6

      a  b  c
[1,] 25 27 29
[2,] 26 28 30

, , 2, V6

      a  b  c
[1,] 31 33 35
[2,] 32 34 36

, , 3, V6

      a  b  c
[1,] 37 39 41
[2,] 38 40 42

, , 4, V6

      a  b  c
[1,] 43 45 47
[2,] 44 46 48

, , 1, V7

      a  b  c
[1,] 49 51 53
[2,] 50 52 54

, , 2, V7

      a  b  c
[1,] 55 57 59
[2,] 56 58 60

, , 3, V7

      a  b  c
[1,] 61 63 65
[2,] 62 64 66

, , 4, V7

      a  b  c
[1,] 67 69 71
[2,] 68 70 72

, , 1, V8

      a  b  c
[1,] 73 75 77
[2,] 74 76 78

, , 2, V8

      a  b  c
[1,] 79 81 83
[2,] 80 82 84

, , 3, V8

      a  b  c
[1,] 85 87 89
[2,] 86 88 90

, , 4, V8

      a  b  c
[1,] 91 93 95
[2,] 92 94 96

, , 1, V9

      a   b   c
[1,] 97  99 101
[2,] 98 100 102

, , 2, V9

       a   b   c
[1,] 103 105 107
[2,] 104 106 108

, , 3, V9

       a   b   c
[1,] 109 111 113
[2,] 110 112 114

, , 4, V9

       a   b   c
[1,] 115 117 119
[2,] 116 118 120

> for(m in marg) ## 75% of the time here was spent on the names
+   print(dim(apply(arr, print(m), quantile, names=FALSE)) == c(5,d.arr[m]))
[1] 1 2
[1] TRUE TRUE TRUE
[1] 2 3
[1] TRUE TRUE TRUE
[1] 2 4
[1] TRUE TRUE TRUE
[1] 1 3
[1] TRUE TRUE TRUE
[1] 2 3 4
[1] TRUE TRUE TRUE TRUE
[1] 1 2 3
[1] TRUE TRUE TRUE TRUE
[1] 1 2 3 4
[1] TRUE TRUE TRUE TRUE TRUE
> 
> ## Bessel
> nus <- c(0:5,10,20)
> 
> x0 <- 2^(-20:10)
> plot(x0,x0, log='xy', ylab="", ylim=c(.1,1e60),type='n',
+      main = "Bessel Functions -Y_nu(x)  near 0\n log - log  scale")
> for(nu in sort(c(nus,nus+.5))) lines(x0, -besselY(x0,nu=nu), col = nu+2)
> legend(3,1e50, leg=paste("nu=", paste(nus,nus+.5, sep=",")), col=nus+2, lwd=1)
> 
> x <- seq(3,500);yl <- c(-.3, .2)
> plot(x,x, ylim = yl, ylab="",type='n', main = "Bessel Functions  Y_nu(x)")
> for(nu in nus){xx <- x[x > .6*nu]; lines(xx,besselY(xx,nu=nu), col = nu+2)}
> legend(300,-.08, leg=paste("nu=",nus), col = nus+2, lwd=1)
> 
> x <- seq(10,50000,by=10);yl <- c(-.1, .1)
> plot(x,x, ylim = yl, ylab="",type='n', main = "Bessel Functions  Y_nu(x)")
> for(nu in nus){xx <- x[x > .6*nu]; lines(xx,besselY(xx,nu=nu), col = nu+2)}
> summary(bY <- besselY(2,nu = nu <- seq(0,100,len=501)))
       Min.     1st Qu.      Median        Mean     3rd Qu.        Max. 
-3.001e+155 -1.067e+107  -1.976e+62 -9.961e+152  -2.059e+23   5.104e-01 
> which(bY >= 0)
[1] 1 2 3 4 5
> summary(bY <- besselY(2,nu = nu <- seq(3,300,len=51)))
       Min.     1st Qu.      Median        Mean     3rd Qu.        Max. 
       -Inf        -Inf -2.248e+263        -Inf -3.777e+116  -1.128e+00 
There were 22 warnings (use warnings() to see them)
> summary(bI <- besselI(x = x <- 10:700, 1))
      Min.    1st Qu.     Median       Mean    3rd Qu.       Max. 
 2.671e+03  6.026e+77 3.161e+152 3.501e+299 2.409e+227 1.529e+302 
> ## end of moved from Bessel.Rd
> 
> ## data.frame
> set.seed(123)
> L3 <- LETTERS[1:3]
> str(d <- data.frame(cbind(x=1, y=1:10), fac=sample(L3, 10, repl=TRUE)))
`data.frame':	10 obs. of  3 variables:
 $ x  : num  1 1 1 1 1 1 1 1 1 1
 $ y  : num  1 2 3 4 5 6 7 8 9 10
 $ fac: Factor w/ 2 levels "A","C": 1 1 2 2 2 2 2 2 2 1
> (d0  <- d[, FALSE]) # NULL dataframe with 10 rows
NULL data frame with 10 rows
> (d.0 <- d[FALSE, ]) # <0 rows> dataframe  (3 cols)
[1] x   y   fac
<0 rows> (or 0-length row.names)
> (d00 <- d0[FALSE,])  # NULL dataframe with 0 rows
NULL data frame with 0 rows
> (d000 <- data.frame()) #but not quite the same as d00:
NULL data frame with 0 rows
> !identical(d00, d000)
[1] TRUE
> dput(d00)
structure(list(), .Names = character(0), row.names = character(0), class = "data.frame")
> dput(d000)
structure(list(), row.names = character(0), class = "data.frame")
> stopifnot(identical(d, cbind(d, d0)),
+           identical(d, cbind(d0, d)),
+           identical(d, rbind(d,d.0)),
+           identical(d, rbind(d.0,d)),
+           identical(d, rbind(d00,d)),
+           identical(d, rbind(d,d00)),
+ 
+           TRUE )
> ## Comments: failed before ver. 1.4.0
> 
> ## diag
> diag(array(1:4, dim=5))
     [,1] [,2] [,3] [,4] [,5]
[1,]    1    0    0    0    0
[2,]    0    2    0    0    0
[3,]    0    0    3    0    0
[4,]    0    0    0    4    0
[5,]    0    0    0    0    1
> ## test behaviour with 0 rows or columns
> diag(0)
<0 x 0 matrix>
> z <- matrix(0, 0, 4)
> diag(z)
numeric(0)
> diag(z) <- numeric(0)
> z
     [,1] [,2] [,3] [,4]
> ## end of moved from diag.Rd
> 
> ## format
> ## handling of quotes
> zz <- data.frame(a=I("abc"), b=I("def\"gh"))
> format(zz)
    a      b
1 abc def"gh
> ## " (E fontification)
> 
> ## printing more than 16 is platform-dependent
> for(i in c(1:5,10,15,16)) cat(i,":\t",format(pi,digits=i),"\n")
1 :	 3 
2 :	 3.1 
3 :	 3.14 
4 :	 3.142 
5 :	 3.1416 
10 :	 3.141592654 
15 :	 3.14159265358979 
16 :	 3.141592653589793 
> 
> p <- c(47,13,2,.1,.023,.0045, 1e-100)/1000
> format.pval(p)
[1] "0.0470"  "0.0130"  "0.0020"  "0.0001"  "2.3e-05" "4.5e-06" "< 2e-16"
> format.pval(p / 0.9)
[1] "0.05222222" "0.01444444" "0.00222222" "0.00011111" "2.5556e-05"
[6] "5.0000e-06" "< 2.22e-16"
> format.pval(p / 0.9, dig=3)
[1] "0.052222" "0.014444" "0.002222" "0.000111" "2.56e-05" "5.00e-06" "< 2e-16" 
> ## end of moved from format.Rd
> 
> 
> ## is.finite
> x <- c(100,-1e-13,Inf,-Inf, NaN, pi, NA)
> x #  1.000000 -3.000000       Inf      -Inf        NA  3.141593        NA
[1]  1.000000e+02 -1.000000e-13           Inf          -Inf           NaN
[6]  3.141593e+00            NA
> names(x) <- formatC(x, dig=3)
> is.finite(x)
   100 -1e-13    Inf   -Inf    NaN   3.14     NA 
  TRUE   TRUE  FALSE  FALSE  FALSE   TRUE  FALSE 
> ##-   100 -1e-13 Inf -Inf NaN 3.14 NA
> ##-     T      T   .    .   .    T  .
> is.na(x)
   100 -1e-13    Inf   -Inf    NaN   3.14     NA 
 FALSE  FALSE  FALSE  FALSE   TRUE  FALSE   TRUE 
> ##-   100 -1e-13 Inf -Inf NaN 3.14 NA
> ##-     .      .   .    .   T    .  T
> which(is.na(x) & !is.nan(x))# only 'NA': 7
  NA 
   7 
> 
> is.na(x) | is.finite(x)
   100 -1e-13    Inf   -Inf    NaN   3.14     NA 
  TRUE   TRUE  FALSE  FALSE   TRUE   TRUE   TRUE 
> ##-   100 -1e-13 Inf -Inf NaN 3.14 NA
> ##-     T      T   .    .   T    T  T
> is.infinite(x)
   100 -1e-13    Inf   -Inf    NaN   3.14     NA 
 FALSE  FALSE   TRUE   TRUE  FALSE  FALSE  FALSE 
> ##-   100 -1e-13 Inf -Inf NaN 3.14 NA
> ##-     .      .   T    T   .    .  .
> 
> ##-- either  finite or infinite  or  NA:
> all(is.na(x) != is.finite(x) | is.infinite(x)) # TRUE
[1] TRUE
> all(is.nan(x) != is.finite(x) | is.infinite(x)) # FALSE: have 'real' NA
[1] FALSE
> 
> ##--- Integer
> (ix <- structure(as.integer(x),names= names(x)))
   100 -1e-13    Inf   -Inf    NaN   3.14     NA 
   100      0     NA     NA     NA      3     NA 
Warning message: 
NAs introduced by coercion 
> ##-   100 -1e-13    Inf   -Inf    NaN   3.14     NA
> ##-   100      0     NA     NA     NA      3     NA
> all(is.na(ix) != is.finite(ix) | is.infinite(ix)) # TRUE (still)
[1] TRUE
> 
> storage.mode(ii <- -3:5)
[1] "integer"
> storage.mode(zm <- outer(ii,ii, FUN="*"))# integer
[1] "double"
> storage.mode(zd <- outer(ii,ii, FUN="/"))# double
[1] "double"
> range(zd, na.rm=TRUE)# -Inf  Inf
[1] -Inf  Inf
> zd[,ii==0]
[1] -Inf -Inf -Inf  NaN  Inf  Inf  Inf  Inf  Inf
> 
> (storage.mode(print(1:1 / 0:0)))# Inf "double"
[1] Inf
[1] "double"
> (storage.mode(print(1:1 / 1:1)))# 1 "double"
[1] 1
[1] "double"
> (storage.mode(print(1:1 + 1:1)))# 2 "integer"
[1] 2
[1] "integer"
> (storage.mode(print(2:2 * 2:2)))# 4 "integer"
[1] 4
[1] "integer"
> ## end of moved from is.finite.Rd
> 
> 
> ## kronecker
> fred <- matrix(1:12, 3, 4, dimnames=list(LETTERS[1:3], LETTERS[4:7]))
> bill <- c("happy" = 100, "sad" = 1000)
> kronecker(fred, bill, make.dimnames = TRUE)
          D:   E:   F:    G:
A:happy  100  400  700  1000
A:sad   1000 4000 7000 10000
B:happy  200  500  800  1100
B:sad   2000 5000 8000 11000
C:happy  300  600  900  1200
C:sad   3000 6000 9000 12000
> 
> bill <- outer(bill, c("cat"=3, "dog"=4))
> kronecker(fred, bill, make.dimnames = TRUE)
        D:cat D:dog E:cat E:dog F:cat F:dog G:cat G:dog
A:happy   300   400  1200  1600  2100  2800  3000  4000
A:sad    3000  4000 12000 16000 21000 28000 30000 40000
B:happy   600   800  1500  2000  2400  3200  3300  4400
B:sad    6000  8000 15000 20000 24000 32000 33000 44000
C:happy   900  1200  1800  2400  2700  3600  3600  4800
C:sad    9000 12000 18000 24000 27000 36000 36000 48000
> 
> # dimnames are hard work: let's test them thoroughly
> 
> dimnames(bill) <- NULL
> kronecker(fred, bill, make=TRUE)
     D:    D:    E:    E:    F:    F:    G:    G:
A:  300   400  1200  1600  2100  2800  3000  4000
A: 3000  4000 12000 16000 21000 28000 30000 40000
B:  600   800  1500  2000  2400  3200  3300  4400
B: 6000  8000 15000 20000 24000 32000 33000 44000
C:  900  1200  1800  2400  2700  3600  3600  4800
C: 9000 12000 18000 24000 27000 36000 36000 48000
> kronecker(bill, fred, make=TRUE)
     :D    :E    :F    :G    :D    :E    :F    :G
:A  300  1200  2100  3000   400  1600  2800  4000
:B  600  1500  2400  3300   800  2000  3200  4400
:C  900  1800  2700  3600  1200  2400  3600  4800
:A 3000 12000 21000 30000  4000 16000 28000 40000
:B 6000 15000 24000 33000  8000 20000 32000 44000
:C 9000 18000 27000 36000 12000 24000 36000 48000
> 
> dim(bill) <- c(2, 2, 1)
> dimnames(bill) <- list(c("happy", "sad"), NULL, "")
> kronecker(fred, bill, make=TRUE)
, , :

          D:    D:    E:    E:    F:    F:    G:    G:
A:happy  300   400  1200  1600  2100  2800  3000  4000
A:sad   3000  4000 12000 16000 21000 28000 30000 40000
B:happy  600   800  1500  2000  2400  3200  3300  4400
B:sad   6000  8000 15000 20000 24000 32000 33000 44000
C:happy  900  1200  1800  2400  2700  3600  3600  4800
C:sad   9000 12000 18000 24000 27000 36000 36000 48000

> 
> bill <- array(1:24, c(3, 4, 2))
> dimnames(bill) <- list(NULL, NULL, c("happy", "sad"))
> kronecker(bill, fred, make=TRUE)
, , happy:

   :D :E :F :G :D :E :F :G :D :E :F  :G :D :E  :F  :G
:A  1  4  7 10  4 16 28 40  7 28 49  70 10 40  70 100
:B  2  5  8 11  8 20 32 44 14 35 56  77 20 50  80 110
:C  3  6  9 12 12 24 36 48 21 42 63  84 30 60  90 120
:A  2  8 14 20  5 20 35 50  8 32 56  80 11 44  77 110
:B  4 10 16 22 10 25 40 55 16 40 64  88 22 55  88 121
:C  6 12 18 24 15 30 45 60 24 48 72  96 33 66  99 132
:A  3 12 21 30  6 24 42 60  9 36 63  90 12 48  84 120
:B  6 15 24 33 12 30 48 66 18 45 72  99 24 60  96 132
:C  9 18 27 36 18 36 54 72 27 54 81 108 36 72 108 144

, , sad:

   :D :E  :F  :G :D  :E  :F  :G :D  :E  :F  :G :D  :E  :F  :G
:A 13 52  91 130 16  64 112 160 19  76 133 190 22  88 154 220
:B 26 65 104 143 32  80 128 176 38  95 152 209 44 110 176 242
:C 39 78 117 156 48  96 144 192 57 114 171 228 66 132 198 264
:A 14 56  98 140 17  68 119 170 20  80 140 200 23  92 161 230
:B 28 70 112 154 34  85 136 187 40 100 160 220 46 115 184 253
:C 42 84 126 168 51 102 153 204 60 120 180 240 69 138 207 276
:A 15 60 105 150 18  72 126 180 21  84 147 210 24  96 168 240
:B 30 75 120 165 36  90 144 198 42 105 168 231 48 120 192 264
:C 45 90 135 180 54 108 162 216 63 126 189 252 72 144 216 288

> kronecker(fred, bill, make=TRUE)
, , :happy

   D: D: D: D: E: E: E: E: F: F: F:  F: G: G:  G:  G:
A:  1  4  7 10  4 16 28 40  7 28 49  70 10 40  70 100
A:  2  5  8 11  8 20 32 44 14 35 56  77 20 50  80 110
A:  3  6  9 12 12 24 36 48 21 42 63  84 30 60  90 120
B:  2  8 14 20  5 20 35 50  8 32 56  80 11 44  77 110
B:  4 10 16 22 10 25 40 55 16 40 64  88 22 55  88 121
B:  6 12 18 24 15 30 45 60 24 48 72  96 33 66  99 132
C:  3 12 21 30  6 24 42 60  9 36 63  90 12 48  84 120
C:  6 15 24 33 12 30 48 66 18 45 72  99 24 60  96 132
C:  9 18 27 36 18 36 54 72 27 54 81 108 36 72 108 144

, , :sad

   D: D: D: D: E:  E:  E:  E:  F:  F:  F:  F:  G:  G:  G:  G:
A: 13 16 19 22 52  64  76  88  91 112 133 154 130 160 190 220
A: 14 17 20 23 56  68  80  92  98 119 140 161 140 170 200 230
A: 15 18 21 24 60  72  84  96 105 126 147 168 150 180 210 240
B: 26 32 38 44 65  80  95 110 104 128 152 176 143 176 209 242
B: 28 34 40 46 70  85 100 115 112 136 160 184 154 187 220 253
B: 30 36 42 48 75  90 105 120 120 144 168 192 165 198 231 264
C: 39 48 57 66 78  96 114 132 117 144 171 198 156 192 228 264
C: 42 51 60 69 84 102 120 138 126 153 180 207 168 204 240 276
C: 45 54 63 72 90 108 126 144 135 162 189 216 180 216 252 288

> 
> fred <- outer(fred, c("frequentist"=4, "bayesian"=4000))
> kronecker(fred, bill, make=TRUE)
, , frequentist:happy

   D: D:  D:  D: E:  E:  E:  E:  F:  F:  F:  F:  G:  G:  G:  G:
A:  4 16  28  40 16  64 112 160  28 112 196 280  40 160 280 400
A:  8 20  32  44 32  80 128 176  56 140 224 308  80 200 320 440
A: 12 24  36  48 48  96 144 192  84 168 252 336 120 240 360 480
B:  8 32  56  80 20  80 140 200  32 128 224 320  44 176 308 440
B: 16 40  64  88 40 100 160 220  64 160 256 352  88 220 352 484
B: 24 48  72  96 60 120 180 240  96 192 288 384 132 264 396 528
C: 12 48  84 120 24  96 168 240  36 144 252 360  48 192 336 480
C: 24 60  96 132 48 120 192 264  72 180 288 396  96 240 384 528
C: 36 72 108 144 72 144 216 288 108 216 324 432 144 288 432 576

, , frequentist:sad

    D:  D:  D:  D:  E:  E:  E:  E:  F:  F:  F:  F:  G:  G:   G:   G:
A:  52  64  76  88 208 256 304 352 364 448 532 616 520 640  760  880
A:  56  68  80  92 224 272 320 368 392 476 560 644 560 680  800  920
A:  60  72  84  96 240 288 336 384 420 504 588 672 600 720  840  960
B: 104 128 152 176 260 320 380 440 416 512 608 704 572 704  836  968
B: 112 136 160 184 280 340 400 460 448 544 640 736 616 748  880 1012
B: 120 144 168 192 300 360 420 480 480 576 672 768 660 792  924 1056
C: 156 192 228 264 312 384 456 528 468 576 684 792 624 768  912 1056
C: 168 204 240 276 336 408 480 552 504 612 720 828 672 816  960 1104
C: 180 216 252 288 360 432 504 576 540 648 756 864 720 864 1008 1152

, , bayesian:happy

      D:    D:     D:     D:    E:     E:     E:     E:     F:     F:     F:
A:  4000 16000  28000  40000 16000  64000 112000 160000  28000 112000 196000
A:  8000 20000  32000  44000 32000  80000 128000 176000  56000 140000 224000
A: 12000 24000  36000  48000 48000  96000 144000 192000  84000 168000 252000
B:  8000 32000  56000  80000 20000  80000 140000 200000  32000 128000 224000
B: 16000 40000  64000  88000 40000 100000 160000 220000  64000 160000 256000
B: 24000 48000  72000  96000 60000 120000 180000 240000  96000 192000 288000
C: 12000 48000  84000 120000 24000  96000 168000 240000  36000 144000 252000
C: 24000 60000  96000 132000 48000 120000 192000 264000  72000 180000 288000
C: 36000 72000 108000 144000 72000 144000 216000 288000 108000 216000 324000
       F:     G:     G:     G:     G:
A: 280000  40000 160000 280000 400000
A: 308000  80000 200000 320000 440000
A: 336000 120000 240000 360000 480000
B: 320000  44000 176000 308000 440000
B: 352000  88000 220000 352000 484000
B: 384000 132000 264000 396000 528000
C: 360000  48000 192000 336000 480000
C: 396000  96000 240000 384000 528000
C: 432000 144000 288000 432000 576000

, , bayesian:sad

       D:     D:     D:     D:     E:     E:     E:     E:     F:     F:     F:
A:  52000  64000  76000  88000 208000 256000 304000 352000 364000 448000 532000
A:  56000  68000  80000  92000 224000 272000 320000 368000 392000 476000 560000
A:  60000  72000  84000  96000 240000 288000 336000 384000 420000 504000 588000
B: 104000 128000 152000 176000 260000 320000 380000 440000 416000 512000 608000
B: 112000 136000 160000 184000 280000 340000 400000 460000 448000 544000 640000
B: 120000 144000 168000 192000 300000 360000 420000 480000 480000 576000 672000
C: 156000 192000 228000 264000 312000 384000 456000 528000 468000 576000 684000
C: 168000 204000 240000 276000 336000 408000 480000 552000 504000 612000 720000
C: 180000 216000 252000 288000 360000 432000 504000 576000 540000 648000 756000
       F:     G:     G:      G:      G:
A: 616000 520000 640000  760000  880000
A: 644000 560000 680000  800000  920000
A: 672000 600000 720000  840000  960000
B: 704000 572000 704000  836000  968000
B: 736000 616000 748000  880000 1012000
B: 768000 660000 792000  924000 1056000
C: 792000 624000 768000  912000 1056000
C: 828000 672000 816000  960000 1104000
C: 864000 720000 864000 1008000 1152000

> ## end of moved from kronecker.Rd
> 
> ## merge
> authors <- data.frame(
+     surname = c("Tukey", "Venables", "Tierney", "Ripley", "McNeil"),
+     nationality = c("US", "Australia", "US", "UK", "Australia"),
+     deceased = c("yes", rep("no", 4)))
> books <- data.frame(
+     name = c("Tukey", "Venables", "Tierney",
+              "Ripley", "Ripley", "McNeil", "R Core"),
+     title = c("Exploratory Data Analysis",
+               "Modern Applied Statistics ...",
+               "LISP-STAT",
+               "Spatial Statistics", "Stochastic Simulation",
+               "Interactive Data Analysis",
+               "An Introduction to R"),
+     other.author = c(NA, "Ripley", NA, NA, NA, NA,
+                      "Venables & Smith"))
> b2 <- books; names(b2)[1] <- names(authors)[1]
> 
> merge(authors, b2, all.x = TRUE)
   surname nationality deceased                         title other.author
1   McNeil   Australia       no     Interactive Data Analysis         <NA>
2   Ripley          UK       no            Spatial Statistics         <NA>
3   Ripley          UK       no         Stochastic Simulation         <NA>
4  Tierney          US       no                     LISP-STAT         <NA>
5    Tukey          US      yes     Exploratory Data Analysis         <NA>
6 Venables   Australia       no Modern Applied Statistics ...       Ripley
> merge(authors, b2, all.y = TRUE)
   surname nationality deceased                         title     other.author
1   McNeil   Australia       no     Interactive Data Analysis             <NA>
2   Ripley          UK       no            Spatial Statistics             <NA>
3   Ripley          UK       no         Stochastic Simulation             <NA>
4  Tierney          US       no                     LISP-STAT             <NA>
5    Tukey          US      yes     Exploratory Data Analysis             <NA>
6 Venables   Australia       no Modern Applied Statistics ...           Ripley
7   R Core        <NA>     <NA>          An Introduction to R Venables & Smith
> 
> ## empty d.f. :
> merge(authors, b2[7,])
[1] surname      nationality  deceased     title        other.author
<0 rows> (or 0-length row.names)
> 
> merge(authors, b2[7,], all.y = TRUE)
  surname nationality deceased                title     other.author
1  R Core        <NA>     <NA> An Introduction to R Venables & Smith
> merge(authors, b2[7,], all.x = TRUE)
   surname nationality deceased title other.author
1   McNeil   Australia       no  <NA>         <NA>
2   Ripley          UK       no  <NA>         <NA>
3  Tierney          US       no  <NA>         <NA>
4    Tukey          US      yes  <NA>         <NA>
5 Venables   Australia       no  <NA>         <NA>
> ## end of moved from merge.Rd
> 
> ## NA
> is.na(c(1,NA))
[1] FALSE  TRUE
> is.na(paste(c(1,NA)))
[1] FALSE FALSE
> is.na(list())# logical(0)
logical(0)
> ll <- list(pi,"C",NaN,Inf, 1:3, c(0,NA), NA)
> is.na (ll)
[1] FALSE FALSE  TRUE FALSE FALSE FALSE  TRUE
> is.nan(ll)
[1] FALSE FALSE  TRUE FALSE FALSE FALSE FALSE
> ## end of moved from NA.Rd
> 
> ## scale
> ## test out NA handling
> tm <- matrix(c(2,1,0,1,0,NA,NA,NA,0), nrow=3)
> scale(tm, , FALSE)
     [,1] [,2] [,3]
[1,]    1  0.5   NA
[2,]    0 -0.5   NA
[3,]   -1   NA    0
attr(,"scaled:center")
[1] 1.0 0.5 0.0
> scale(tm)
     [,1]       [,2] [,3]
[1,]    1  0.7071068   NA
[2,]    0 -0.7071068   NA
[3,]   -1         NA  NaN
attr(,"scaled:center")
[1] 1.0 0.5 0.0
attr(,"scaled:scale")
[1] 1.0000000 0.7071068 0.0000000
> ## end of moved from scale.Rd
> 
> ## tabulate
> tabulate(numeric(0))
[1] 0
> ## end of moved from tabulate.Rd
> 
> ## ts
> # Ensure working arithmetic for `ts' objects :
> stopifnot(z == z)
> stopifnot(z-z == 0)
> 
> ts(1:5, start=2, end=4) # truncate
Time Series:
Start = 2 
End = 4 
Frequency = 1 
[1] 1 2 3
> ts(1:5, start=3, end=17)# repeat
Time Series:
Start = 3 
End = 17 
Frequency = 1 
 [1] 1 2 3 4 5 1 2 3 4 5 1 2 3 4 5
> ## end of moved from ts.Rd
> 
> ### end of moved
> 
> 
> ## PR 715 (Printing list elements w/attributes)
> ##
> l <- list(a=10)
> attr(l$a, "xx") <- 23
> l
$a
[1] 10
attr(,"xx")
[1] 23

> ## Comments:
> ## should print as
> # $a:
> # [1] 10
> # attr($a, "xx"):
> # [1] 23
> 
> ## On the other hand
> m <- matrix(c(1, 2, 3, 0, 10, NA), 3, 2)
> na.omit(m)
     [,1] [,2]
[1,]    1    0
[2,]    2   10
attr(,"na.action")
[1] 3
attr(,"class")
[1] "omit"
> ## should print as
> #      [,1] [,2]
> # [1,]    1    0
> # [2,]    2   10
> # attr(,"na.action")
> # [1] 3
> # attr(,"na.action")
> # [1] "omit"
> 
> ## and
> x <- 1
> attr(x, "foo") <- list(a="a")
> x
[1] 1
attr(,"foo")
attr(,"foo")$a
[1] "a"

> ## should print as
> # [1] 1
> # attr(,"foo")
> # attr(,"foo")$a
> # [1] "a"
> 
> 
> ## PR 746 (printing of lists)
> ##
> test.list <- list(A = list(formula=Y~X, subset=TRUE),
+                   B = list(formula=Y~X, subset=TRUE))
> 
> test.list
$A
$A$formula
Y ~ X

$A$subset
[1] TRUE


$B
$B$formula
Y ~ X

$B$subset
[1] TRUE


> ## Comments:
> ## should print as
> # $A
> # $A$formula
> # Y ~ X
> #
> # $A$subset
> # [1] TRUE
> #
> #
> # $B
> # $B$formula
> # Y ~ X
> #
> # $B$subset
> # [1] TRUE
> 
> ## Marc Feldesman 2001-Feb-01.  Precision in summary.data.frame & *.matrix
> data(attenu)
> summary(attenu)
     event              mag             station             dist        
 Min.   : 1.00     Min.   :5.000     117    :  5       Min.   :  0.50   
 1st Qu.: 9.00     1st Qu.:5.300     1028   :  4       1st Qu.: 11.32   
 Median :18.00     Median :6.100     113    :  4       Median : 23.40   
 Mean   :14.74     Mean   :6.084     112    :  3       Mean   : 45.60   
 3rd Qu.:20.00     3rd Qu.:6.600     135    :  3       3rd Qu.: 47.55   
 Max.   :23.00     Max.   :7.700     (Other):147       Max.   :370.00   
                                     NA's   : 16                        
     accel        
 Min.   :0.00300  
 1st Qu.:0.04425  
 Median :0.11300  
 Mean   :0.15422  
 3rd Qu.:0.21925  
 Max.   :0.81000  
                  
> summary(attenu, digits = 5)
     event              mag             station             dist        
 Min.   : 1.000    Min.   :5.0000    117    :  5       Min.   :  0.500  
 1st Qu.: 9.000    1st Qu.:5.3000    1028   :  4       1st Qu.: 11.325  
 Median :18.000    Median :6.1000    113    :  4       Median : 23.400  
 Mean   :14.742    Mean   :6.0841    112    :  3       Mean   : 45.603  
 3rd Qu.:20.000    3rd Qu.:6.6000    135    :  3       3rd Qu.: 47.550  
 Max.   :23.000    Max.   :7.7000    (Other):147       Max.   :370.000  
                                     NA's   : 16                        
     accel        
 Min.   :0.00300  
 1st Qu.:0.04425  
 Median :0.11300  
 Mean   :0.15422  
 3rd Qu.:0.21925  
 Max.   :0.81000  
                  
> summary(data.matrix(attenu), digits = 5)# the same for matrix
     event              mag             station             dist        
 Min.   : 1.000    Min.   :5.0000    Min.   :  1.000   Min.   :  0.500  
 1st Qu.: 9.000    1st Qu.:5.3000    1st Qu.: 24.250   1st Qu.: 11.325  
 Median :18.000    Median :6.1000    Median : 56.500   Median : 23.400  
 Mean   :14.742    Mean   :6.0841    Mean   : 56.928   Mean   : 45.603  
 3rd Qu.:20.000    3rd Qu.:6.6000    3rd Qu.: 86.750   3rd Qu.: 47.550  
 Max.   :23.000    Max.   :7.7000    Max.   :117.000   Max.   :370.000  
                                     NA's   : 16.000                    
     accel        
 Min.   :0.00300  
 1st Qu.:0.04425  
 Median :0.11300  
 Mean   :0.15422  
 3rd Qu.:0.21925  
 Max.   :0.81000  
                  
> ## Comments:
> ## No difference between these in 1.2.1 and earlier
> set.seed(1)
> x <- c(round(runif(10), 2), 10000)
> summary(x)
     Min.   1st Qu.    Median      Mean   3rd Qu.      Max. 
    0.000     0.050     0.550   909.400     0.675 10000.000 
> summary(data.frame(x))
       x            
 Min.   :    0.000  
 1st Qu.:    0.050  
 Median :    0.550  
 Mean   :  909.423  
 3rd Qu.:    0.675  
 Max.   :10000.000  
> ## Comments:
> ## All entries show all 3 digits after the decimal point now.
> 
> ## Chong Gu 2001-Feb-16.  step on binomials
> "detg1" <-
+ structure(list(Temp = structure(c(2, 1, 2, 1, 2, 1, 2, 1, 2,
+ 1, 2, 1), .Label = c("High", "Low"), class = "factor"), M.user = structure(c(1,
+ 1, 2, 2, 1, 1, 2, 2, 1, 1, 2, 2), .Label = c("N", "Y"), class = "factor"),
+     Soft = structure(c(1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3), .Label = c("Hard",
+     "Medium", "Soft"), class = "factor"), M = c(42, 30, 52, 43,
+     50, 23, 55, 47, 53, 27, 49, 29), X = c(68, 42, 37, 24, 66,
+     33, 47, 23, 63, 29, 57, 19)), .Names = c("Temp", "M.user",
+ "Soft", "M", "X"), class = "data.frame", row.names = c("1", "3",
+ "5", "7", "9", "11", "13", "15", "17", "19", "21", "23"))
> detg1.m0 <- glm(cbind(X,M)~1,binomial,detg1)
> detg1.m0

Call:  glm(formula = cbind(X, M) ~ 1, family = binomial, data = detg1) 

Coefficients:
(Intercept)  
    0.01587  

Degrees of Freedom: 11 Total (i.e. Null);  11 Residual
Null Deviance:	    32.83 
Residual Deviance: 32.83 	AIC: 92.52 
> step(detg1.m0,scope=list(upper=~M.user*Temp*Soft))
Start:  AIC= 92.52 
 cbind(X, M) ~ 1 

         Df Deviance    AIC
+ M.user  1   12.244 73.942
+ Temp    1   28.464 90.162
<none>        32.826 92.524
+ Soft    2   32.430 96.128

Step:  AIC= 73.94 
 cbind(X, M) ~ M.user 

         Df Deviance    AIC
+ Temp    1    8.444 72.142
<none>        12.244 73.942
+ Soft    2   11.967 77.665
- M.user  1   32.826 92.524

Step:  AIC= 72.14 
 cbind(X, M) ~ M.user + Temp 

              Df Deviance    AIC
+ M.user:Temp  1    5.656 71.354
<none>              8.444 72.142
- Temp         1   12.244 73.942
+ Soft         2    8.228 75.926
- M.user       1   28.464 90.162

Step:  AIC= 71.35 
 cbind(X, M) ~ M.user + Temp + M.user:Temp 

              Df Deviance    AIC
<none>              5.656 71.354
- M.user:Temp  1    8.444 72.142
+ Soft         2    5.495 75.193

Call:  glm(formula = cbind(X, M) ~ M.user + Temp + M.user:Temp, family = binomial,      data = detg1) 

Coefficients:
    (Intercept)          M.userY          TempLow  M.userY:TempLow  
        0.26236         -0.85183          0.04411          0.44427  

Degrees of Freedom: 11 Total (i.e. Null);  8 Residual
Null Deviance:	    32.83 
Residual Deviance: 5.656 	AIC: 71.35 
> 
> ## PR 829 (empty values in all.vars)
> ## This example by Uwe Ligges <ligges@statistik.uni-dortmund.de>
> 
> temp <- matrix(1:4, 2)
> all.vars(temp ~ 3) # OK
[1] "temp"
> all.vars(temp[1, ] ~ 3) # wrong in 1.2.1
[1] "temp"
> 
> ## 2001-Feb-22 from David Scott.
> ## rank-deficient residuals in a manova model.
> gofX.df<-
+   structure(list(A = c(0.696706709347165, 0.362357754476673,
+ -0.0291995223012888,
+ 0.696706709347165, 0.696706709347165, -0.0291995223012888, 0.696706709347165,
+ -0.0291995223012888, 0.362357754476673, 0.696706709347165, -0.0291995223012888,
+ 0.362357754476673, -0.416146836547142, 0.362357754476673, 0.696706709347165,
+ 0.696706709347165, 0.362357754476673, -0.416146836547142, -0.0291995223012888,
+ -0.416146836547142, 0.696706709347165, -0.416146836547142, 0.362357754476673,
+ -0.0291995223012888), B = c(0.717356090899523, 0.932039085967226,
+ 0.999573603041505, 0.717356090899523, 0.717356090899523, 0.999573603041505,
+ 0.717356090899523, 0.999573603041505, 0.932039085967226, 0.717356090899523,
+ 0.999573603041505, 0.932039085967226, 0.909297426825682, 0.932039085967226,
+ 0.717356090899523, 0.717356090899523, 0.932039085967226, 0.909297426825682,
+ 0.999573603041505, 0.909297426825682, 0.717356090899523, 0.909297426825682,
+ 0.932039085967226, 0.999573603041505), C = c(-0.0291995223012888,
+ -0.737393715541246, -0.998294775794753, -0.0291995223012888,
+ -0.0291995223012888, -0.998294775794753, -0.0291995223012888,
+ -0.998294775794753, -0.737393715541246, -0.0291995223012888,
+ -0.998294775794753, -0.737393715541246, -0.653643620863612, -0.737393715541246,
+ -0.0291995223012888, -0.0291995223012888, -0.737393715541246,
+ -0.653643620863612, -0.998294775794753, -0.653643620863612,
+ -0.0291995223012888,
+ -0.653643620863612, -0.737393715541246, -0.998294775794753),
+     D = c(0.999573603041505, 0.67546318055115, -0.0583741434275801,
+     0.999573603041505, 0.999573603041505, -0.0583741434275801,
+     0.999573603041505, -0.0583741434275801, 0.67546318055115,
+     0.999573603041505, -0.0583741434275801, 0.67546318055115,
+     -0.756802495307928, 0.67546318055115, 0.999573603041505,
+     0.999573603041505, 0.67546318055115, -0.756802495307928,
+     -0.0583741434275801, -0.756802495307928, 0.999573603041505,
+     -0.756802495307928, 0.67546318055115, -0.0583741434275801
+     ), groups = structure(c(1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2,
+     2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3), class = "factor", .Label = c("1",
+     "2", "3"))), .Names = c("A", "B", "C", "D", "groups"), row.names = c("1",
+ "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "13",
+ "14", "15", "16", "17", "18", "19", "20", "21", "22", "23", "24"
+ ), class = "data.frame")
> 
> gofX.manova <- manova(formula = cbind(A, B, C, D) ~ groups, data = gofX.df)
> try(summary(gofX.manova))
Error in summary.manova(gofX.manova) : residuals have rank 3 < 4
> ## should fail with an error message `residuals have rank 3 < 4'
> 
> ## Prior to 1.3.0 dist did not handle missing values, and the
> ## internal C code was incorrectly scaling for missing values.
> data(trees)
> z <- as.matrix(t(trees))
> z[1,1] <- z[2,2] <- z[3,3] <- z[2,4] <- NA
> dist(z, method="euclidean")
          Girth   Height
Height 352.4365         
Volume 123.5503 261.5802
> dist(z, method="maximum")
       Girth Height
Height  72.7       
Volume  56.4   63.3
> dist(z, method="manhattan")
           Girth   Height
Height 1954.8821         
Volume  557.1448 1392.343
> dist(z, method="canberra")
          Girth   Height
Height 21.66477         
Volume 10.96200 13.63365
> 
> ## F. Tusell 2001-03-07.  printing kernels.
> kernel("daniell", m=5)
Daniell(5) 
coef[-5] = 0.09091
coef[-4] = 0.09091
coef[-3] = 0.09091
coef[-2] = 0.09091
coef[-1] = 0.09091
coef[ 0] = 0.09091
coef[ 1] = 0.09091
coef[ 2] = 0.09091
coef[ 3] = 0.09091
coef[ 4] = 0.09091
coef[ 5] = 0.09091
> kernel("modified.daniell", m=5)
mDaniell(5) 
coef[-5] = 0.05
coef[-4] = 0.10
coef[-3] = 0.10
coef[-2] = 0.10
coef[-1] = 0.10
coef[ 0] = 0.10
coef[ 1] = 0.10
coef[ 2] = 0.10
coef[ 3] = 0.10
coef[ 4] = 0.10
coef[ 5] = 0.05
> kernel("daniell", m=c(3,5,7))
unknown 
coef[-15] = 0.0008658
coef[-14] = 0.0025974
coef[-13] = 0.0051948
coef[-12] = 0.0086580
coef[-11] = 0.0129870
coef[-10] = 0.0181818
coef[ -9] = 0.0242424
coef[ -8] = 0.0303030
coef[ -7] = 0.0363636
coef[ -6] = 0.0424242
coef[ -5] = 0.0484848
coef[ -4] = 0.0536797
coef[ -3] = 0.0580087
coef[ -2] = 0.0614719
coef[ -1] = 0.0640693
coef[  0] = 0.0649351
coef[  1] = 0.0640693
coef[  2] = 0.0614719
coef[  3] = 0.0580087
coef[  4] = 0.0536797
coef[  5] = 0.0484848
coef[  6] = 0.0424242
coef[  7] = 0.0363636
coef[  8] = 0.0303030
coef[  9] = 0.0242424
coef[ 10] = 0.0181818
coef[ 11] = 0.0129870
coef[ 12] = 0.0086580
coef[ 13] = 0.0051948
coef[ 14] = 0.0025974
coef[ 15] = 0.0008658
> ## fixed by patch from Adrian Trapletti 2001-03-08
> 
> ## Start new year (i.e. line) at Jan:
> (tt <- ts(1:10, start = c(1920,7), end = c(1921,4), freq = 12))
     Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec
1920                           1   2   3   4   5   6
1921   7   8   9  10                                
> cbind(tt, tt + 1)
         tt tt + 1
Jul 1920  1      2
Aug 1920  2      3
Sep 1920  3      4
Oct 1920  4      5
Nov 1920  5      6
Dec 1920  6      7
Jan 1921  7      8
Feb 1921  8      9
Mar 1921  9     10
Apr 1921 10     11
> 
> 
> ## PR 883 (cor(x,y) when is.null(y))
> try(cov(rnorm(10), NULL))
Error in cov(rnorm(10), NULL) : supply both x and y or a matrix-like x
> try(cor(rnorm(10), NULL))
Error in cor(rnorm(10), NULL) : supply both x and y or a matrix-like x
> ## gave the variance and 1 respectively in 1.2.2.
> try(var(NULL))
Error in var(NULL) : `x' is empty
> try(var(numeric(0)))
Error in var(numeric(0)) : `x' is empty
> ## gave NA in 1.2.2
> 
> 
> ## PR 960 (format() of a character matrix converts to vector)
> ## example from <John.Peters@tip.csiro.au>
> a <- matrix(c("axx","b","c","d","e","f","g","h"), nrow=2)
> format(a)
     [,1]  [,2]  [,3]  [,4] 
[1,] "axx" "c  " "e  " "g  "
[2,] "b  " "d  " "f  " "h  "
> format(a, justify="right")
     [,1]  [,2]  [,3]  [,4] 
[1,] "axx" "  c" "  e" "  g"
[2,] "  b" "  d" "  f" "  h"
> ## lost dimensions in 1.2.3
> 
> 
> ## PR 963
> res <- svd(rbind(1:7))## $v lost dimensions in 1.2.3
> if(res$u[1,1] < 0) {res$u <- -res$u; res$v <- -res$v}
> res
$d
[1] 11.83216

$u
     [,1]
[1,]    1

$v
           [,1]
[1,] 0.08451543
[2,] 0.16903085
[3,] 0.25354628
[4,] 0.33806170
[5,] 0.42257713
[6,] 0.50709255
[7,] 0.59160798

> 
> 
> ## Make sure  on.exit() keeps being evaluated in the proper env [from PD]:
> ## A more complete example:
> g1 <- function(fitted) { on.exit(remove(fitted)); return(function(foo) foo) }
> g2 <- function(fitted) { on.exit(remove(fitted));        function(foo) foo }
> f <- function(g) { fitted <- 1; h <- g(fitted); print(fitted)
+                    ls(envir=environment(h)) }
> f(g1)
[1] 1
character(0)
> f(g2)
[1] 1
character(0)
> 
> f2 <- function()
+ {
+   g.foo <- g1
+   g.bar <- g2
+   g <- function(x,...) UseMethod("g")
+   fitted <- 1; class(fitted) <- "foo"
+   h <- g(fitted); print(fitted); print(ls(envir=environment(h)))
+   fitted <- 1; class(fitted) <- "bar"
+   h <- g(fitted); print(fitted); print(ls(envir=environment(h)))
+   invisible(NULL)
+ }
> f2()
[1] 1
attr(,"class")
[1] "foo"
character(0)
[1] 1
attr(,"class")
[1] "bar"
character(0)
> ## The first case in f2() is broken in 1.3.0(-patched).
> 
> ## on.exit() consistency check from Luke:
> g <- function() as.environment(-1)
> f <- function(x) UseMethod("f")
> f.foo <- function(x) { on.exit(e <<- g()); NULL }
> f.bar <- function(x) { on.exit(e <<- g()); return(NULL) }
> f(structure(1,class = "foo"))
NULL
> ls(env = e)# only "x", i.e. *not* the GlobalEnv
[1] "x"
> f(structure(1,class = "bar"))
NULL
> stopifnot("x" == ls(env = e))# as above; wrongly was .GlobalEnv in R 1.3.x
> 
> 
> ## some tests that R supports logical variables in formulae
> ## it coerced them to numeric prior to 1.4.0
> ## they should appear like 2-level factors, following S
> 
> oldCon <- options("contrasts")
> y <- rnorm(10)
> x <- rep(c(TRUE, FALSE), 5)
> model.matrix(y ~ x)
   (Intercept) xTRUE
1            1     1
2            1     0
3            1     1
4            1     0
5            1     1
6            1     0
7            1     1
8            1     0
9            1     1
10           1     0
attr(,"assign")
[1] 0 1
attr(,"contrasts")
attr(,"contrasts")$x
[1] "contr.treatment"

> lm(y ~ x)

Call:
lm(formula = y ~ x)

Coefficients:
(Intercept)        xTRUE  
     0.1230       0.3170  

> DF <- data.frame(x, y)
> lm(y ~ x, data=DF)

Call:
lm(formula = y ~ x, data = DF)

Coefficients:
(Intercept)        xTRUE  
     0.1230       0.3170  

> options(contrasts=c("contr.helmert", "contr.poly"))
> model.matrix(y ~ x)
   (Intercept) x1
1            1  1
2            1 -1
3            1  1
4            1 -1
5            1  1
6            1 -1
7            1  1
8            1 -1
9            1  1
10           1 -1
attr(,"assign")
[1] 0 1
attr(,"contrasts")
attr(,"contrasts")$x
[1] "contr.helmert"

> lm(y ~ x, data=DF)

Call:
lm(formula = y ~ x, data = DF)

Coefficients:
(Intercept)           x1  
     0.2814       0.1585  

> z <- 1:10
> lm(y ~ x*z)

Call:
lm(formula = y ~ x * z)

Coefficients:
(Intercept)           x1            z         x1:z  
    0.49064     -0.68273     -0.02433      0.15074  

> lm(y ~ x*z - 1)

Call:
lm(formula = y ~ x * z - 1)

Coefficients:
  xFALSE     xTRUE         z      x1:z  
 1.17337  -0.19209  -0.02433   0.15074  

> options(oldCon)
> 
> ## diffinv, Adrian Trapletti, 2001-08-27
> x <- ts(1:10)
> diffinv(diff(x),xi=x[1])
Time Series:
Start = 1 
End = 10 
Frequency = 1 
 [1]  1  2  3  4  5  6  7  8  9 10
> diffinv(diff(x,lag=1,differences=2),lag=1,differences=2,xi=x[1:2])
Time Series:
Start = 1 
End = 10 
Frequency = 1 
 [1]  1  2  3  4  5  6  7  8  9 10
> ## last had wrong start and end
> 
> ## PR#1072  (Reading Inf and NaN values)
> as.numeric(as.character(NaN))
[1] NaN
> as.numeric(as.character(Inf))
[1] Inf
> ## were NA on Windows at least under 1.3.0.
> 
> ## PR#1092 (rowsum dimnames)
> rowsum(matrix(1:12, 3,4), c("Y","X","Y"))
  [,1] [,2] [,3] [,4]
X    2    5    8   11
Y    4   10   16   22
> ## rownames were 1,2 in <= 1.3.1.
> 
> ## PR#1115 (saving strings with ascii=TRUE)
> x <- y <- unlist(as.list(
+     parse(text=paste("\"\\",
+           as.character(structure(0:255,class="octmode")),
+              "\"",sep=""))))
> save(x, ascii=T, file=(fn <- tempfile()))
> load(fn)
> all(x==y)
[1] TRUE
> unlink(fn)
> ## 1.3.1 had trouble with \
> 
> 
> ## Some tests of sink() and connections()
> ## capture all the output to a file.
> zz <- file("all.Rout", open="wt")
> sink(zz)
> sink(zz, type="message")
> try(log("a"))
> ## back to the console
> sink(type="message")
> sink()
> try(log("a"))
Error in log(x) : Non-numeric argument to mathematical function
> 
> ## capture all the output to a file.
> zz <- file("all.Rout", open="wt")
> sink(zz)
> sink(zz, type="message")
> try(log("a"))
> 
> ## bail out
> closeAllConnections()
> (foo <- showConnections())
     description class mode text isopen can read can write
> stopifnot(nrow(foo) == 0)
> try(log("a"))
Error in log(x) : Non-numeric argument to mathematical function
> unlink("all.Rout")
> ## many of these were untested before 1.4.0.
> 
> 
> ## test mean() works on logical but not factor
> x <- c(TRUE, FALSE, TRUE, TRUE)
> mean(x)
[1] 0.75
> mean(as.factor(x))
[1] NA
Warning message: 
argument is not numeric or logical: returning NA in: mean.default(as.factor(x)) 
> ## last had confusing error message in 1.3.1.
> 
> 
> ## Kurt Hornik 2001-Nov-13
> z <- table(x = 1:2, y = 1:2)
> z - 1
   y
x   1  2 
  1  0 -1
  2 -1  0
> unclass(z - 1)
   y
x    1  2
  1  0 -1
  2 -1  0
> ## lost object bit prior to 1.4.0, so printed class attribute.
> 
> 
> ## PR#1226  (predict.mlm ignored newdata)
> ctl <- c(4.17,5.58,5.18,6.11,4.50,4.61,5.17,4.53,5.33,5.14)
> trt <- c(4.81,4.17,4.41,3.59,5.87,3.83,6.03,4.89,4.32,4.69)
> group <- gl(2,10,20, labels = c("Ctl","Trt"))
> weight <- c(ctl, trt)
> data <- data.frame(weight, group)
> fit <- lm(cbind(w=weight, w2=weight^2) ~ group, data=data)
> predict(fit, newdata=data[1:2, ])
   
        w       w2
  1 5.032 25.62702
  2 5.032 25.62702
> ## was 20 rows in R <= 1.4.0
> 
> 
> ## Chong Gu 2002-Feb-8: `.' not expanded in drop1
> data(HairEyeColor)
> lab <- dimnames(HairEyeColor)
> HairEye <- cbind(expand.grid(Hair=lab$Hair, Eye=lab$Eye, Sex=lab$Sex),
+                  Fr=as.vector(HairEyeColor))
> HairEye.fit <- glm(Fr ~ . ^2, poisson, HairEye)
> drop1(HairEye.fit)
Single term deletions

Model:
Fr ~ .^2
         Df Deviance    AIC
<none>          8.19 192.94
Hair:Eye  9   162.21 328.96
Hair:Sex  3    22.03 200.78
Eye:Sex   3    23.08 201.83
> ## broken around 1.2.1 it seems.
> 
> 
> ## PR#1329  (subscripting matrix lists)
> m <- list(a1=1:3, a2=4:6, a3=pi, a4=c("a","b","c"))
> dim(m) <- c(2,2)
> m
     [,1]      [,2]       
[1,] Integer,3 3.141593   
[2,] Integer,3 Character,3
> m[,2]
[[1]]
[1] 3.141593

[[2]]
[1] "a" "b" "c"

> m[2,2]
[[1]]
[1] "a" "b" "c"

> ## 1.4.1 returned null components: the case was missing from a switch.
> 
> m <- list(a1=1:3, a2=4:6, a3=pi, a4=c("a","b","c"))
> matrix(m, 2, 2)
     [,1]      [,2]       
[1,] Integer,3 3.141593   
[2,] Integer,3 Character,3
> ## 1.4.1 gave `Unimplemented feature in copyVector'
> 
> x <- vector("list",6)
> dim(x) <- c(2,3)
> x[1,2] <- list(letters[10:11])
> x
     [,1] [,2]        [,3]
[1,] NULL Character,2 NULL
[2,] NULL NULL        NULL
> ## 1.4.1 gave `incompatible types in subset assignment'
> 
> 
> ## printing of matrix lists
> m <- list(as.integer(1), pi, 3+5i, "testit", TRUE, factor("foo"))
> dim(m) <- c(1, 6)
> m
     [,1] [,2]     [,3] [,4]     [,5] [,6]    
[1,] 1    3.141593 3+5i "testit" TRUE factor,1
> ## prior to 1.5.0 had quotes for 2D case (but not kD, k > 2),
> ## gave "numeric,1" etc, (even "numeric,1" for integers and factors)
> 
> 
> ## ensure RNG is unaltered.
> for(type in c("Wichmann-Hill", "Marsaglia-Multicarry", "Super-Duper",
+               "Mersenne-Twister", "Knuth-TAOCP", "Knuth-TAOCP-2002"))
+ {
+     set.seed(123, type)
+     print(RNGkind())
+     runif(100); print(runif(4))
+     set.seed(1000, type)
+     runif(100); print(runif(4))
+     set.seed(77, type)
+     runif(100); print(runif(4))
+ }
[1] "Wichmann-Hill"    "Kinderman-Ramage"
[1] 0.8308841 0.4640221 0.9460082 0.8764644
[1] 0.12909876 0.07294851 0.45594560 0.68884911
[1] 0.4062450 0.7188432 0.6241738 0.2511611
[1] "Marsaglia-Multicarry" "Kinderman-Ramage"    
[1] 0.3479705 0.9469351 0.2489207 0.7329251
[1] 0.5041512 0.3617873 0.1469184 0.3798119
[1] 0.14388128 0.04196294 0.36214015 0.86053575
[1] "Super-Duper"      "Kinderman-Ramage"
[1] 0.2722510 0.9230240 0.3971743 0.8284474
[1] 0.5706241 0.1806023 0.9633860 0.8434444
[1] 0.09356585 0.41081124 0.38635627 0.72993396
[1] "Mersenne-Twister" "Kinderman-Ramage"
[1] 0.5999890 0.3328235 0.4886130 0.9544738
[1] 0.5993679 0.4516818 0.1368254 0.7261788
[1] 0.09594961 0.31235651 0.81244335 0.72330846
[1] "Knuth-TAOCP"      "Kinderman-Ramage"
[1] 0.9445502 0.3366297 0.6296881 0.5914161
[1] 0.9213954 0.5468138 0.8817100 0.4442237
[1] 0.8016962 0.9226080 0.1473484 0.8827707
[1] "Knuth-TAOCP-2002" "Kinderman-Ramage"
[1] 0.9303634 0.2812239 0.1085806 0.8053228
[1] 0.2916627 0.9085017 0.7958965 0.1980655
[1] 0.05247575 0.28290867 0.20930324 0.16794887
> RNGkind(normal.kind = "Kinderman-Ramage")
> set.seed(123)
> RNGkind()
[1] "Knuth-TAOCP-2002" "Kinderman-Ramage"
> rnorm(4)
[1] -1.9699090 -2.2429340  0.5339321  0.2097153
> RNGkind(normal.kind = "Ahrens-Dieter")
> set.seed(123)
> RNGkind()
[1] "Knuth-TAOCP-2002" "Ahrens-Dieter"   
> rnorm(4)
[1]  0.06267229  0.12421568 -1.86653499 -0.14535921
> RNGkind(normal.kind = "Box-Muller")
> set.seed(123)
> RNGkind()
[1] "Knuth-TAOCP-2002" "Box-Muller"      
> rnorm(4)
[1]  2.26160990  0.59010303  0.30176045 -0.01346139
> set.seed(123)
> runif(4)
[1] 0.04062130 0.06511825 0.99290488 0.95540467
> set.seed(123, "default")
> set.seed(123, "Marsaglia-Multicarry") ## Careful, not the default anymore
> runif(4)
[1] 0.1200427 0.1991600 0.7292821 0.8115922
> ## last set.seed failed < 1.5.0.
> 
> 
> ## merging, ggrothendieck@yifan.net, 2002-03-16
> d.df <- data.frame(x = 1:3, y = c("A","D","E"), z = c(6,9,10))
> merge(d.df[1,], d.df)
  x y z
1 1 A 6
> ## 1.4.1 got confused by inconsistencies in as.character
> 
> 
> ## PR#1394 (levels<-.factor)
> f <- factor(c("a","b"))
> levels(f) <- list(C="C", A="a", B="b")
> f
[1] A B
Levels: C A B
> ## was  [1] C A; Levels:  C A  in 1.4.1
> 
> 
> ## PR#1408 Inconsistencies in sum()
> x <- as.integer(2^30)
> sum(x, x)    # did not warn in 1.4.1
[1] NA
Warning message: 
Integer overflow in sum(.); use sum(as.numeric(.)) 
> sum(c(x, x)) # did warn
[1] NA
Warning message: 
Integer overflow in sum(.); use sum(as.numeric(.)) 
> (z <- sum(x, x, 0.0)) # was NA in 1.4.1
[1] 2147483648
> typeof(z)
[1] "double"
> 
> 
> ## NA levels in factors
> (x <- factor(c("a", "NA", "b"), exclude=NULL))
[1] a  NA b 
Levels: NA a b
> ## 1.4.1 had wrong order for levels
> is.na(x)[3] <- TRUE
> x
[1] a    NA   <NA>
Levels: NA a b
> ## missing entry prints as <NA>
> 
> 
> ## printing/formatting NA strings
> (x <- c("a", "NA", NA, "b"))
[1] "a"  "NA" NA   "b" 
> print(x, quote = FALSE)
[1] a    NA   <NA> b   
> paste(x)
[1] "a"  "NA" "NA" "b" 
> format(x)
[1] "a " "NA" "NA" "b "
> format(x, justify = "right")
[1] " a" "NA" "NA" " b"
> format(x, justify = "none")
[1] "a"  "NA" NA   "b" 
> ## not ideal.
> 
> 
> ## print.ts problems  ggrothendieck@yifan.net on R-help, 2002-04-01
> x <- 1:20
> tt1 <- ts(x,start=c(1960,2), freq=12)
> tt2 <- ts(10+x,start=c(1960,2), freq=12)
> cbind(tt1, tt2)
         tt1 tt2
Feb 1960   1  11
Mar 1960   2  12
Apr 1960   3  13
May 1960   4  14
Jun 1960   5  15
Jul 1960   6  16
Aug 1960   7  17
Sep 1960   8  18
Oct 1960   9  19
Nov 1960  10  20
Dec 1960  11  21
Jan 1960  12  22
Feb 1961  13  23
Mar 1961  14  24
Apr 1961  15  25
May 1961  16  26
Jun 1961  17  27
Jul 1961  18  28
Aug 1961  19  29
Sep 1961  20  30
> ## 1.4.1 had `Jan 1961' as `NA 1961'
> 
> ## glm boundary bugs (related to PR#1331)
> x <- c(0.35, 0.64, 0.12, 1.66, 1.52, 0.23, -1.99, 0.42, 1.86, -0.02,
+        -1.64, -0.46, -0.1, 1.25, 0.37, 0.31, 1.11, 1.65, 0.33, 0.89,
+        -0.25, -0.87, -0.22, 0.71, -2.26, 0.77, -0.05, 0.32, -0.64, 0.39,
+        0.19, -1.62, 0.37, 0.02, 0.97, -2.62, 0.15, 1.55, -1.41, -2.35,
+        -0.43, 0.57, -0.66, -0.08, 0.02, 0.24, -0.33, -0.03, -1.13, 0.32,
+        1.55, 2.13, -0.1, -0.32, -0.67, 1.44, 0.04, -1.1, -0.95, -0.19,
+        -0.68, -0.43, -0.84, 0.69, -0.65, 0.71, 0.19, 0.45, 0.45, -1.19,
+        1.3, 0.14, -0.36, -0.5, -0.47, -1.31, -1.02, 1.17, 1.51, -0.33,
+        -0.01, -0.59, -0.28, -0.18, -1.07, 0.66, -0.71, 1.88, -0.14,
+        -0.19, 0.84, 0.44, 1.33, -0.2, -0.45, 1.46, 1, -1.02, 0.68, 0.84)
> y <- c(1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0,
+        0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 1, 1,
+        1, 0, 1, 1, 0, 1, 0, 0, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 0, 1,
+        0, 1, 0, 1, 1, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 1, 1, 1, 0, 0, 1,
+        1, 0, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 0, 0)
> try(glm(y ~ x, family = poisson(identity)))
Error: no valid set of coefficients has been found:please supply starting values
In addition: Warning message: 
NaNs produced in: log(x) 
> ## failed because start = NULL in 1.4.1
> ## now gives useful error message
> glm(y ~ x, family = poisson(identity), start = c(1,0))

Call:  glm(formula = y ~ x, family = poisson(identity), start = c(1,      0)) 

Coefficients:
(Intercept)            x  
     0.5113       0.1709  

Degrees of Freedom: 99 Total (i.e. Null);  98 Residual
Null Deviance:	    68.01 
Residual Deviance: 60.67 	AIC: 168.7 
Warning messages: 
1: Step size truncated: out of bounds 
2: Step size truncated: out of bounds 
> ## step reduction failed in 1.4.1
> set.seed(123)
> y <- rpois(100, pmax(3*x, 0))
> glm(y ~ x, family = poisson(identity), start = c(1,0))

Call:  glm(formula = y ~ x, family = poisson(identity), start = c(1,      0)) 

Coefficients:
(Intercept)            x  
     1.1078       0.4228  

Degrees of Freedom: 99 Total (i.e. Null);  98 Residual
Null Deviance:	    317.2 
Residual Deviance: 230.2 	AIC: 346.4 
There were 12 warnings (use warnings() to see them)
> warnings()
Warning messages:
1: Step size truncated: out of bounds
2: Step size truncated: out of bounds
3: Step size truncated: out of bounds
4: Step size truncated: out of bounds
5: Step size truncated: out of bounds
6: Step size truncated: out of bounds
7: Step size truncated: out of bounds
8: Step size truncated: out of bounds
9: Step size truncated: out of bounds
10: Step size truncated: out of bounds
11: Algorithm did not converge in: (if (is.empty.model(mt)) glm.fit.null else glm.fit)(x = X, y = Y,   ...
12: Algorithm stopped at boundary value in: (if (is.empty.model(mt)) glm.fit.null else glm.fit)(x = X, y = Y,   ...
> 
> 
> ## extending char arrrays
> x <- y <- LETTERS[1:2]
> x[5] <- "C"
> length(y) <- 5
> x
[1] "A" "B" NA  NA  "C"
> y
[1] "A" "B" NA  NA  NA 
> ## x was filled with "", y with NA in 1.5.0
> 
> 
> ## formula with no intercept, 2002-07-22
> oldcon <- options(contrasts = c("contr.helmert", "contr.poly"))
> U <- gl(3, 6, 18, labels=letters[1:3])
> V <- gl(3, 2, 18, labels=letters[1:3])
> A <- rep(c(0, 1), 9)
> B <- rep(c(1, 0), 9)
> set.seed(1); y <- rnorm(18)
> terms(y ~ A:U + A:V - 1)
y ~ A:U + A:V - 1
attr(,"variables")
list(y, A, U, V)
attr(,"factors")
  A:U A:V
y   0   0
A   2   2
U   2   0
V   0   1
attr(,"term.labels")
[1] "A:U" "A:V"
attr(,"order")
[1] 2 2
attr(,"intercept")
[1] 0
attr(,"response")
[1] 1
attr(,".Environment")
<environment: R_GlobalEnv>
> lm(y ~ A:U + A:V - 1)$coef  # 1.5.1 used dummies coding for V
       A:Ua        A:Ub        A:Uc        A:V1        A:V2 
 0.25303884 -0.21875499 -0.71708528 -0.61467193 -0.09030436 
> lm(y ~ (A + B) : (U + V) - 1) # 1.5.1 used dummies coding for A:V but not B:V

Call:
lm(formula = y ~ (A + B):(U + V) - 1)

Coefficients:
   A:Ua     A:Ub     A:Uc     A:V1     A:V2     B:Ua     B:Ub     B:Uc  
 0.2530  -0.2188  -0.7171  -0.6147  -0.0903   1.7428   0.0613   0.7649  
   B:V1     B:V2  
-0.4420   0.5388  

> options(oldcon)
> ## 1.5.1 miscomputed the first factor in the formula.
> 
> 
> ## quantile extremes, MM 13 Apr 2000 and PR#1852
> for(k in 0:5)
+     print(quantile(c(rep(-Inf,k+1), 0:k, rep(Inf, k)), pr=seq(0,1, .1)))
  0%  10%  20%  30%  40%  50%  60%  70%  80%  90% 100% 
-Inf  NaN  NaN  NaN  NaN  NaN  NaN  NaN  NaN  NaN    0 
  0%  10%  20%  30%  40%  50%  60%  70%  80%  90% 100% 
-Inf -Inf -Inf  NaN  NaN  0.0  0.4  0.8  Inf  Inf  Inf 
  0%  10%  20%  30%  40%  50%  60%  70%  80%  90% 100% 
-Inf -Inf -Inf  NaN  NaN  0.5  1.2  1.9  Inf  Inf  Inf 
  0%  10%  20%  30%  40%  50%  60%  70%  80%  90% 100% 
-Inf -Inf -Inf -Inf    0    1    2    3  Inf  Inf  Inf 
  0%  10%  20%  30%  40%  50%  60%  70%  80%  90% 100% 
-Inf -Inf -Inf -Inf  0.2  1.5  2.8  Inf  Inf  Inf  Inf 
  0%  10%  20%  30%  40%  50%  60%  70%  80%  90% 100% 
-Inf -Inf -Inf -Inf  0.4  2.0  3.6  Inf  Inf  Inf  Inf 
> x <- c(-Inf, -Inf, Inf, Inf)
> median(x)
[1] NaN
> quantile(x)
  0%  25%  50%  75% 100% 
-Inf -Inf  NaN  Inf  Inf 
> ## 1.5.1 had -Inf not NaN in several places
> 
> 
> ## NAs in matrix dimnames
> z <- matrix(1:9, 3, 3)
> dimnames(z) <- list(c("x", "y", NA), c(1, NA, 3))
> z
     1 <NA> 3
x    1    4 7
y    2    5 8
<NA> 3    6 9
> ## NAs in dimnames misaligned when printing in 1.5.1
> 
> 
> ## weighted aov (PR#1930)
> r <- c(10,23,23,26,17,5,53,55,32,46,10,8,10,8,23,0,3,22,15,32,3)
> n <- c(39,62,81,51,39,6,74,72,51,79,13,16,30,28,45,4,12,41,30,51,7)
> trt <- factor(rep(1:4,c(5,6,5,5)))
> Y <- r/n
> z <- aov(Y ~ trt, weights=n)
> ## 1.5.1 gave unweighted RSS
> 
> 
> ## rbind (PR#2266)
> test <- as.data.frame(matrix(1:25, 5, 5))
> test1 <- matrix(-(1:10), 2, 5)
> rbind(test, test1)
   V1 V2 V3 V4  V5
1   1  6 11 16  21
2   2  7 12 17  22
3   3  8 13 18  23
4   4  9 14 19  24
5   5 10 15 20  25
11 -1 -3 -5 -7  -9
22 -2 -4 -6 -8 -10
> rbind(test1, test)
   V1 V2 V3 V4  V5
1  -1 -3 -5 -7  -9
2  -2 -4 -6 -8 -10
11  1  6 11 16  21
22  2  7 12 17  22
3   3  8 13 18  23
4   4  9 14 19  24
5   5 10 15 20  25
> ## 1.6.1 treated matrix as a vector.
> 
> 
> ## escapes in non-quoted printing
> x <- "\\abc\\"
> names(x) <- 1
> x
        1 
"\\abc\\" 
> print(x, quote=FALSE)
      1 
\\abc\\ 
> ## 1.6.2 had label misaligned
> 
> 
> ## summary on data frames containing data frames (PR#1891)
> x <- data.frame(1:10)
> x$z <- data.frame(x=1:10,yyy=11:20)
> summary(x)
     X1.10                              z.x             z.yyy     
 Min.   : 1.00                    Min.   : 1.00    Min.   :11.00  
 1st Qu.: 3.25                    1st Qu.: 3.25    1st Qu.:13.25  
 Median : 5.50                    Median : 5.50    Median :15.50  
 Mean   : 5.50                    Mean   : 5.50    Mean   :15.50  
 3rd Qu.: 7.75                    3rd Qu.: 7.75    3rd Qu.:17.75  
 Max.   :10.00                    Max.   :10.00    Max.   :20.00  
> ## 1.6.2 had NULL labels on output with z columns stacked.
> 
> 
> ## re-orderings in terms.formula (PR#2206)
> form <- formula(y ~ a + b:c + d + e + e:d)
> (tt <- terms(form))
y ~ a + b:c + d + e + e:d
attr(,"variables")
list(y, a, b, c, d, e)
attr(,"factors")
  a d e b:c d:e
y 0 0 0   0   0
a 1 0 0   0   0
b 0 0 0   2   0
c 0 0 0   2   0
d 0 1 0   0   1
e 0 0 1   0   1
attr(,"term.labels")
[1] "a"   "d"   "e"   "b:c" "d:e"
attr(,"order")
[1] 1 1 1 2 2
attr(,"intercept")
[1] 1
attr(,"response")
[1] 1
attr(,".Environment")
<environment: R_GlobalEnv>
> (tt2 <- terms(formula(tt)))
y ~ a + b:c + d + e + e:d
attr(,"variables")
list(y, a, b, c, d, e)
attr(,"factors")
  a d e b:c d:e
y 0 0 0   0   0
a 1 0 0   0   0
b 0 0 0   2   0
c 0 0 0   2   0
d 0 1 0   0   1
e 0 0 1   0   1
attr(,"term.labels")
[1] "a"   "d"   "e"   "b:c" "d:e"
attr(,"order")
[1] 1 1 1 2 2
attr(,"intercept")
[1] 1
attr(,"response")
[1] 1
attr(,".Environment")
<environment: R_GlobalEnv>
> stopifnot(identical(tt, tt2))
> terms(delete.response(tt))
~a + b:c + d + e + e:d
attr(,"variables")
list(a, b, c, d, e)
attr(,"factors")
  a d e b:c d:e
a 1 0 0   0   0
b 0 0 0   2   0
c 0 0 0   2   0
d 0 1 0   0   1
e 0 0 1   0   1
attr(,"term.labels")
[1] "a"   "d"   "e"   "b:c" "d:e"
attr(,"order")
[1] 1 1 1 2 2
attr(,"intercept")
[1] 1
attr(,"response")
[1] 0
attr(,".Environment")
<environment: R_GlobalEnv>
> ## both tt and tt2 re-ordered the formula < 1.7.0
> ## now try with a dot
> data(warpbreaks)
> terms(breaks ~ ., data = warpbreaks)
breaks ~ wool + tension
attr(,"variables")
list(breaks, wool, tension)
attr(,"factors")
        wool tension
breaks     0       0
wool       1       0
tension    0       1
attr(,"term.labels")
[1] "wool"    "tension"
attr(,"order")
[1] 1 1
attr(,"intercept")
[1] 1
attr(,"response")
[1] 1
attr(,".Environment")
<environment: R_GlobalEnv>
> terms(breaks ~ . - tension, data = warpbreaks)
breaks ~ (wool + tension) - tension
attr(,"variables")
list(breaks, wool, tension)
attr(,"factors")
        wool
breaks     0
wool       1
tension    0
attr(,"term.labels")
[1] "wool"
attr(,"order")
[1] 1
attr(,"intercept")
[1] 1
attr(,"response")
[1] 1
attr(,".Environment")
<environment: R_GlobalEnv>
> terms(breaks ~ . - tension, data = warpbreaks, simplify = TRUE)
breaks ~ wool
attr(,"variables")
list(breaks, wool, tension)
attr(,"factors")
        wool
breaks     0
wool       1
tension    0
attr(,"term.labels")
[1] "wool"
attr(,"order")
[1] 1
attr(,"intercept")
[1] 1
attr(,"response")
[1] 1
attr(,".Environment")
<environment: R_GlobalEnv>
> terms(breaks ~ . ^2, data = warpbreaks)
breaks ~ (wool + tension)^2
attr(,"variables")
list(breaks, wool, tension)
attr(,"factors")
        wool tension wool:tension
breaks     0       0            0
wool       1       0            1
tension    0       1            1
attr(,"term.labels")
[1] "wool"         "tension"      "wool:tension"
attr(,"order")
[1] 1 1 2
attr(,"intercept")
[1] 1
attr(,"response")
[1] 1
attr(,".Environment")
<environment: R_GlobalEnv>
> terms(breaks ~ . ^2, data = warpbreaks, simplify = TRUE)
breaks ~ wool + tension + wool:tension
attr(,"variables")
list(breaks, wool, tension)
attr(,"factors")
        wool tension wool:tension
breaks     0       0            0
wool       1       0            1
tension    0       1            1
attr(,"term.labels")
[1] "wool"         "tension"      "wool:tension"
attr(,"order")
[1] 1 1 2
attr(,"intercept")
[1] 1
attr(,"response")
[1] 1
attr(,".Environment")
<environment: R_GlobalEnv>
> ## 1.6.2 expanded these formulae out as in simplify = TRUE
> 
> 
> ## printing attributes (PR#2506)
> (x <- structure(1:4, other=as.factor(LETTERS[1:3])))
[1] 1 2 3 4
attr(,"other")
[1] A B C
Levels: A B C
> ## < 1.7.0 printed the codes of the factor attribute
> 
> 
> ## add logical matrix replacement indexing for data frames
> TEMP <- data.frame(VAR1=c(1,2,3,4,5), VAR2=c(5,4,3,2,1), VAR3=c(1,1,1,1,NA))
> TEMP[,c(1,3)][TEMP[,c(1,3)]==1 & !is.na(TEMP[,c(1,3)])] < -10
    1  <NA>  <NA>  <NA>  <NA> 
FALSE FALSE FALSE FALSE FALSE 
> TEMP
  VAR1 VAR2 VAR3
1    1    5    1
2    2    4    1
3    3    3    1
4    4    2    1
5    5    1   NA
> ##
> 
> ## moved from reg-plot.R as exact output depends on rounding error
> ## PR 390 (axis for small ranges)
> 
> relrange <- function(x) {
+     ## The relative range in EPS units
+     r <- range(x)
+     diff(r)/max(abs(r))/.Machine$double.eps
+ }
> 
> x <- c(0.12345678912345678,
+        0.12345678912345679,
+        0.12345678912345676)
> relrange(x) ## 1.0125
[1] 1.0125
> plot(x) # `extra horizontal' ;  +- ok on Solaris; label off on Linux
> 
> y <- c(0.9999563255363383973418,
+        0.9999563255363389524533,
+        0.9999563255363382863194)
> ## The relative range number:
> relrange(y) ## 3.000131
[1] 3.000131
> plot(y)# once gave infinite loop on Solaris [TL];  y-axis too long
> 
> ## Comments: The whole issue was finally deferred to main/graphics.c l.1944
> ##    error("relative range of values is too small to compute accurately");
> ## which is not okay.
> 
> set.seed(101)
> par(mfrow = c(3,3))
> for(j.fac in 1e-12* c(10, 1, .7, .3, .2, .1, .05, .03, .01)) {
+ ##           ====
+     #set.seed(101) # or don't
+     x <- pi + jitter(numeric(101), f = j.fac)
+     rrtxt <- paste("rel.range =", formatC(relrange(x), dig = 4),"* EPS")
+     cat("j.f = ", format(j.fac)," ;  ", rrtxt,"\n",sep="")
+     plot(x, type = "l", main = rrtxt)
+     cat("par(\"usr\")[3:4]:", formatC(par("usr")[3:4], wid = 10),"\n",
+         "par(\"yaxp\") :   ", formatC(par("yaxp"), wid = 10),"\n\n", sep="")
+ }
j.f = 1e-11 ;  rel.range = 553.9 * EPS
par("usr")[3:4]:     3.142     3.142
par("yaxp") :        3.142     3.142         3

j.f = 1e-12 ;  rel.range = 56.02 * EPS
par("usr")[3:4]:     3.142     3.142
par("yaxp") :        3.142     3.142         1

j.f = 7e-13 ;  rel.range = 39.47 * EPS
par("usr")[3:4]:     3.142     3.142
par("yaxp") :        3.142     3.142         1

j.f = 3e-13 ;  rel.range = 16.55 * EPS
par("usr")[3:4]:     3.142     3.142
par("yaxp") :        3.142     3.142         1

j.f = 2e-13 ;  rel.range = 11.46 * EPS
par("usr")[3:4]:     3.108     3.176
par("yaxp") :         3.11      3.17         6

j.f = 1e-13 ;  rel.range = 5.093 * EPS
par("usr")[3:4]:     3.108     3.176
par("yaxp") :         3.11      3.17         6

j.f = 5e-14 ;  rel.range = 2.546 * EPS
par("usr")[3:4]:     3.108     3.176
par("yaxp") :         3.11      3.17         6

j.f = 3e-14 ;  rel.range = 1.273 * EPS
par("usr")[3:4]:     3.108     3.176
par("yaxp") :         3.11      3.17         6

j.f = 1e-14 ;  rel.range =     0 * EPS
par("usr")[3:4]:     1.784     4.499
par("yaxp") :            2         4         4

Warning messages: 
1: relative range of values =  43 * EPS, is small (axis 2). 
2: relative range of values =  36 * EPS, is small (axis 2). 
3: relative range of values =  17 * EPS, is small (axis 2). 
> par(mfrow = c(1,1))
> ## The warnings from inside GScale() will differ in their  relrange() ...
> ## >> do sloppy testing
> ## 2003-02-03 hopefully no more.  BDR
> ## end of PR 390
> 
> 
> ## print/show dispatch
> hasMethods <- .isMethodsDispatchOn()
> require(methods)
[1] TRUE
> setClass("bar", representation(a="numeric"))
[1] "bar"
> foo <- new("bar", a=pi)
> foo
An object of class "bar"
Slot "a":
[1] 3.141593

> show(foo)
An object of class "bar"
Slot "a":
[1] 3.141593

> print(foo)
An object of class "bar"
Slot "a":
[1] 3.141593

> 
> setMethod("show", "bar", function(object){cat("show method\n")})
[1] "show"
> show(foo)
show method
> foo
show method
> print(foo)
show method
> print(foo, digits = 4)
An object of class "bar"
Slot "a":
[1] 3.142
> 
> print.bar <- function(x, ...) cat("print method\n")
> foo
print method
> print(foo)
print method
> show(foo)
show method
> 
> setMethod("print", "bar", function(x, ...){cat("S4 print method\n")})
Creating a new generic function for "print" 
[1] "print"
> foo
S4 print method
> print(foo)
S4 print method
> show(foo)
show method
> print(foo, digits = 4)
S4 print method
> if(!hasMethods) detach("package:methods")
> ##
> 
> 
> ## scoping rules calling step inside a function
> if(require(MASS)) { # only for "cement"
+     teststep <- function(formula, data)
+     {
+         d2 <- data
+         fit <- lm(formula, data=d2)
+         step(fit)
+     }
+     teststep(formula(y ~ .), cement)
+     detach("package:MASS")
+ }
Loading required package: MASS 
Start:  AIC= 26.94 
 y ~ x1 + x2 + x3 + x4 

       Df Sum of Sq    RSS    AIC
- x3    1     0.109 47.973 24.974
- x4    1     0.247 48.111 25.011
- x2    1     2.972 50.836 25.728
<none>              47.864 26.944
- x1    1    25.951 73.815 30.576

Step:  AIC= 24.97 
 y ~ x1 + x2 + x4 

       Df Sum of Sq    RSS    AIC
<none>               47.97  24.97
- x4    1      9.93  57.90  25.42
- x2    1     26.79  74.76  28.74
- x1    1    820.91 868.88  60.63
> ## failed in 1.6.2
> 
> str(array(1))# not a scalar
 num [, 1] 1
> 
> ## na.print="" shouldn't apply to (dim)names!
> (tf <- table(ff <- factor(c(1:2,NA,2), exclude=NULL)))

   1    2 <NA> 
   1    2    1 
> identical(levels(ff), dimnames(tf)[[1]])
[1] TRUE
> str(levels(ff))
 chr [1:3] "1" "2" NA
> ## not quite ok previous to 1.7.0
> 
> ## str() for character & factors with NA (levels), and for Surv objects:
> ff <- factor(c(2:1,  NA),  exclude = NULL)
> str(levels(ff))
 chr [1:3] "1" "2" NA
> str(ff)
 Factor w/ 3 levels "1","2",NA: 2 1 3
> str(ordered(ff, exclude=NULL))
 Ord.factor w/ 3 levels "1"<"2"<NA: 2 1 3
> if(require(survival)) {
+     data(aml)
+     (sa <- Surv(aml$time, aml$status))
+     str(sa)
+     detach("package:survival")
+ }
Loading required package: survival 
 Surv [1:23, 1:2]  9  13  13+ 18  23  28+ 31  34  45+ 48  ...
 - attr(*, "dimnames")=List of 2
  ..$ : NULL
  ..$ : chr [1:2] "time" "status"
 - attr(*, "type")= chr "right"
> ## were different, the last one failed in 1.6.2 (at least)
> 
