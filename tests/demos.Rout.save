
R : Copyright 2003, The R Development Core Team
Version 1.7.0 Under development (unstable) (2003-02-04)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type `license()' or `licence()' for distribution details.

R is a collaborative project with many contributors.
Type `contributors()' for more information.

Type `demo()' for some demos, `help()' for on-line help, or
`help.start()' for a HTML browser interface to help.
Type `q()' to quit R.

> #### Run all demos that do not depend on tcl and other specials.
> .ptime <- proc.time()
> .Random.seed <- c(0,rep(7654, 3))
> 
> ## Drop these for strict testing {and add them to demos2.R)
> ## in ../src/library/base/man/demo.Rd }:
> dont <- list(base = c("Hershey", "Japanese", "nlm", "plotmath")
+              )
> ## don't take tcltk here
> for(pkg in c("base", "eda")) {
+ 
+     demos <- list.files(file.path(system.file(package = pkg), "demo"),
+                         pattern = "\\.R$")
+     demos <- demos[is.na(match(demos, paste(dont[[pkg]], "R",sep=".")))]
+ 
+     if(length(demos)) {
+         if(need <- pkg != "base" &&
+            !any((fpkg <- paste("package", pkg, sep=":")) == search()))
+             library(pkg, character.only = TRUE)
+ 
+         for(nam in sub("\\.R$", "", demos))
+             demo(nam, character.only = TRUE)
+ 
+         if(need) detach(pos = which(fpkg == search()))
+     }
+ }


	demo(glm.vr)
	---- ~~~~~~

> Fr <- c(68, 42, 42, 30, 37, 52, 24, 43, 66, 50, 33, 
    23, 47, 55, 23, 47, 63, 53, 29, 27, 57, 49, 19, 29)

> Temp <- gl(2, 2, 24, labels = c("Low", "High"))

> Soft <- gl(3, 8, 24, labels = c("Hard", "Medium", 
    "Soft"))

> M.user <- gl(2, 4, 24, labels = c("N", "Y"))

> Brand <- gl(2, 1, 24, labels = c("X", "M"))

> detg <- data.frame(Fr, Temp, Soft, M.user, Brand)

> detg.m0 <- glm(Fr ~ M.user * Temp * Soft + Brand, 
    family = poisson, data = detg)

> summary(detg.m0)

Call:
glm(formula = Fr ~ M.user * Temp * Soft + Brand, family = poisson, 
    data = detg)

Deviance Residuals: 
      Min         1Q     Median         3Q        Max  
-2.208775  -0.991898  -0.001264   0.935415   1.975997  

Coefficients:
                            Estimate Std. Error z value Pr(>|z|)    
(Intercept)                  4.01524    0.10032  40.025  < 2e-16 ***
M.userY                     -0.21184    0.14256  -1.486  0.13727    
TempHigh                    -0.42381    0.15158  -2.796  0.00517 ** 
SoftMedium                   0.05311    0.13307   0.399  0.68982    
SoftSoft                     0.05311    0.13307   0.399  0.68982    
BrandM                      -0.01587    0.06299  -0.252  0.80103    
M.userY:TempHigh             0.13987    0.22163   0.631  0.52798    
M.userY:SoftMedium           0.08323    0.19684   0.423  0.67243    
M.userY:SoftSoft             0.12169    0.19590   0.621  0.53447    
TempHigh:SoftMedium         -0.30442    0.22238  -1.369  0.17101    
TempHigh:SoftSoft           -0.30442    0.22238  -1.369  0.17102    
M.userY:TempHigh:SoftMedium  0.21189    0.31569   0.671  0.50209    
M.userY:TempHigh:SoftSoft   -0.20387    0.32536  -0.627  0.53092    
---
Signif. codes:  0 `***' 0.001 `**' 0.01 `*' 0.05 `.' 0.1 ` ' 1 

(Dispersion parameter for poisson family taken to be 1)

    Null deviance: 118.627  on 23  degrees of freedom
Residual deviance:  32.826  on 11  degrees of freedom
AIC: 191.24

Number of Fisher Scoring iterations: 3


> detg.mod <- glm(terms(Fr ~ M.user * Temp * Soft + 
    Brand * M.user * Temp, keep.order = TRUE), family = poisson, 
    data = detg)

> summary(detg.mod, correlation = FALSE)

Call:
glm(formula = terms(Fr ~ M.user * Temp * Soft + Brand * M.user * 
    Temp, keep.order = TRUE), family = poisson, data = detg)

Deviance Residuals: 
      Min         1Q     Median         3Q        Max  
-0.913649  -0.355846   0.002531   0.330274   0.921460  

Coefficients:
                            Estimate Std. Error z value Pr(>|z|)    
(Intercept)                  4.14887    0.10603  39.128   <2e-16 ***
M.userY                     -0.40521    0.16188  -2.503   0.0123 *  
TempHigh                    -0.44275    0.17121  -2.586   0.0097 ** 
M.userY:TempHigh            -0.12692    0.26257  -0.483   0.6288    
SoftMedium                   0.05311    0.13308   0.399   0.6898    
SoftSoft                     0.05311    0.13308   0.399   0.6898    
M.userY:SoftMedium           0.08323    0.19685   0.423   0.6725    
M.userY:SoftSoft             0.12169    0.19591   0.621   0.5345    
TempHigh:SoftMedium         -0.30442    0.22239  -1.369   0.1710    
TempHigh:SoftSoft           -0.30442    0.22239  -1.369   0.1710    
M.userY:TempHigh:SoftMedium  0.21189    0.31577   0.671   0.5022    
M.userY:TempHigh:SoftSoft   -0.20387    0.32540  -0.627   0.5310    
BrandM                      -0.30647    0.10942  -2.801   0.0051 ** 
M.userY:BrandM               0.40757    0.15961   2.554   0.0107 *  
TempHigh:BrandM              0.04411    0.18463   0.239   0.8112    
M.userY:TempHigh:BrandM      0.44427    0.26673   1.666   0.0958 .  
---
Signif. codes:  0 `***' 0.001 `**' 0.01 `*' 0.05 `.' 0.1 ` ' 1 

(Dispersion parameter for poisson family taken to be 1)

    Null deviance: 118.627  on 23  degrees of freedom
Residual deviance:   5.656  on  8  degrees of freedom
AIC: 170.07

Number of Fisher Scoring iterations: 3


> symnum(summary(detg.mod, correlation = TRUE)$corr)
                            ( M.sY TmH M.sY:TH SM SS M.Y:SM M.Y:SS TH:SM TH:SS
(Intercept)                 1                                                 
M.userY                     , 1                                               
TempHigh                    , .    1                                          
M.userY:TempHigh            . ,    ,   1                                      
SoftMedium                  , .    .           1                              
SoftSoft                    , .    .           .  1                           
M.userY:SoftMedium          . ,        .       ,  .  1                        
M.userY:SoftSoft            . ,        .       .  ,  .      1                 
TempHigh:SoftMedium         .      ,   .       .  .  .             1          
TempHigh:SoftSoft           .      ,   .       .  .         .      .     1    
M.userY:TempHigh:SoftMedium   .    .   .       .     ,      .      ,     .    
M.userY:TempHigh:SoftSoft     .    .   .          .  .      ,      .     ,    
BrandM                      .                                                 
M.userY:BrandM                .                                               
TempHigh:BrandM                    .   .                                      
M.userY:TempHigh:BrandM            .   .                                      
                            M.Y:TH:SM M.Y:TH:SS B M.Y:B TH:B M.Y:TH:B
(Intercept)                                                          
M.userY                                                              
TempHigh                                                             
M.userY:TempHigh                                                     
SoftMedium                                                           
SoftSoft                                                             
M.userY:SoftMedium                                                   
M.userY:SoftSoft                                                     
TempHigh:SoftMedium                                                  
TempHigh:SoftSoft                                                    
M.userY:TempHigh:SoftMedium 1                                        
M.userY:TempHigh:SoftSoft   .         1                              
BrandM                                          1                    
M.userY:BrandM                                  , 1                  
TempHigh:BrandM                                 . .     1            
M.userY:TempHigh:BrandM                         . .     ,    1       
attr(,"legend")
[1] 0 ` ' 0.3 `.' 0.6 `,' 0.8 `+' 0.9 `*' 0.95 `B' 1

> anova(detg.m0, detg.mod)
Analysis of Deviance Table

Model 1: Fr ~ M.user * Temp * Soft + Brand
Model 2: Fr ~ M.user * Temp * Soft + Brand * M.user * Temp
  Resid. Df Resid. Dev Df Deviance
1        11     32.826            
2         8      5.656  3   27.170


	demo(graphics)
	---- ~~~~~~~~

> if (dev.cur() <= 1) get(getOption("device"))()

> opar <- par(ask = interactive() && (.Device %in% c("X11", 
    "GTK", "gnome", "windows", "Macintosh")))

> x <- rnorm(50)

> opar <- c(opar, par(bg = "white"))

> plot(x, ann = FALSE, type = "n")

> abline(h = 0, col = gray(0.9))

> lines(x, col = "green4", lty = "dotted")

> points(x, bg = "limegreen", pch = 21)

> title(main = "Simple Use of Color In a Plot", xlab = "Just a Whisper of a Label", 
    col.main = "blue", col.lab = gray(0.8), cex.main = 1.2, cex.lab = 1, 
    font.main = 4, font.lab = 3)

> par(bg = "gray")

> pie(rep(1, 24), col = rainbow(24), radius = 0.9)

> title(main = "A Sample Color Wheel", cex.main = 1.4, 
    font.main = 3)

> title(xlab = "(Use this as a test of monitor linearity)", 
    cex.lab = 0.8, font.lab = 3)

> pie.sales <- c(0.12, 0.3, 0.26, 0.16, 0.04, 0.12)

> names(pie.sales) <- c("Blueberry", "Cherry", "Apple", 
    "Boston Cream", "Other", "Vanilla Cream")

> pie(pie.sales, col = c("purple", "violetred1", "green3", 
    "cornsilk", "cyan", "white"))

> title(main = "January Pie Sales", cex.main = 1.8, 
    font.main = 1)

> title(xlab = "(Don't try this at home kids)", cex.lab = 0.8, 
    font.lab = 3)

> par(bg = "cornsilk")

> n <- 10

> g <- gl(n, 100, n * 100)

> x <- rnorm(n * 100) + sqrt(codes(g))

> boxplot(split(x, g), col = "lavender", notch = TRUE)

> title(main = "Notched Boxplots", xlab = "Group", font.main = 4, 
    font.lab = 1)

> par(bg = "white")

> n <- 100

> x <- c(0, cumsum(rnorm(n)))

> y <- c(0, cumsum(rnorm(n)))

> xx <- c(0:n, n:0)

> yy <- c(x, rev(y))

> plot(xx, yy, type = "n", xlab = "Time", ylab = "Distance")

> polygon(xx, yy, col = "gray")

> title("Distance Between Brownian Motions")

> x <- c(0, 0.4, 0.86, 0.85, 0.69, 0.48, 0.54, 1.09, 
    1.11, 1.73, 2.05, 2.02)

> par(bg = "lightgray")

> plot(x, type = "n", axes = FALSE, ann = FALSE)

> usr <- par("usr")

> rect(usr[1], usr[3], usr[2], usr[4], col = "cornsilk", 
    border = "black")

> lines(x, col = "blue")

> points(x, pch = 21, bg = "lightcyan", cex = 1.25)

> axis(2, col.axis = "blue", las = 1)

> axis(1, at = 1:12, lab = month.abb, col.axis = "blue")

> box()

> title(main = "The Level of Interest in R", font.main = 4, 
    col.main = "red")

> title(xlab = "1996", col.lab = "red")

> par(bg = "cornsilk")

> x <- rnorm(1000)

> hist(x, xlim = range(-4, 4, x), col = "lavender", 
    main = "")

> title(main = "1000 Normal Random Variates", font.main = 3)

> data("iris")

> pairs(iris[1:4], main = "Edgar Anderson's Iris Data", 
    font.main = 4, pch = 19)

> pairs(iris[1:4], main = "Edgar Anderson's Iris Data", 
    pch = 21, bg = c("red", "green3", "blue")[codes(iris$Species)])

> data("volcano")

> x <- 10 * 1:nrow(volcano)

> y <- 10 * 1:ncol(volcano)

> l <- pretty(range(volcano), 10)

> par(bg = "lightcyan")

> pin <- par("pin")

> xdelta <- diff(range(x))

> ydelta <- diff(range(y))

> xscale <- pin[1]/xdelta

> yscale <- pin[2]/ydelta

> scale <- if (xscale < yscale) xscale else yscale

> xadd <- 0.5 * (pin[1]/scale - xdelta)

> yadd <- 0.5 * (pin[2]/scale - ydelta)

> plot(numeric(0), numeric(0), xlim = range(x) + c(-1, 
    1) * xadd, ylim = range(y) + c(-1, 1) * yadd, type = "n", 
    ann = FALSE)

> usr <- par("usr")

> rect(usr[1], usr[3], usr[2], usr[4], col = "green3")

> contour(x, y, volcano, levels = l, col = "yellow", 
    lty = "solid", add = TRUE)

> box()

> title("A Topographic Map of Maunga Whau", font = 4)

> title(xlab = "Meters North", ylab = "Meters West", 
    font = 3)

> mtext("10 Meter Contour Spacing", side = 3, line = 0.35, 
    outer = FALSE, at = mean(par("usr")[1:2]), cex = 0.7, font = 3)

> par(bg = "cornsilk")

> data(quakes)

> coplot(lat ~ long | depth, data = quakes, pch = 21, 
    bg = "green3")

> par(opar)


	demo(image)
	---- ~~~~~

> if (dev.cur() <= 1) get(getOption("device"))()

> opar <- par(ask = interactive() && (.Device %in% c("X11", 
    "GTK", "windows", "Macintosh")))

> data(volcano)

> x <- 10 * (1:nrow(volcano))

> x.at <- seq(100, 800, by = 100)

> y <- 10 * (1:ncol(volcano))

> y.at <- seq(100, 600, by = 100)

> image(x, y, volcano, col = terrain.colors(100), axes = FALSE)

> contour(x, y, volcano, levels = seq(90, 200, by = 5), 
    add = TRUE, col = "brown")

> axis(1, at = x.at)

> axis(2, at = y.at)

> box()

> title(main = "Maunga Whau Volcano", sub = "col=terrain.colors(100)", 
    font.main = 4)

> image(x, y, volcano, col = heat.colors(100), axes = FALSE)

> contour(x, y, volcano, levels = seq(90, 200, by = 5), 
    add = TRUE, col = "brown")

> axis(1, at = x.at)

> axis(2, at = y.at)

> box()

> title(main = "Maunga Whau Volcano", sub = "col=heat.colors(100)", 
    font.main = 4)

> image(x, y, volcano, col = gray(100:200/200), axes = FALSE)

> contour(x, y, volcano, levels = seq(90, 200, by = 5), 
    add = TRUE, col = "black")

> axis(1, at = x.at)

> axis(2, at = y.at)

> box()

> title(main = "Maunga Whau Volcano \n col=gray(100:200/200)", 
    font.main = 4)

> example(filled.contour)

flld.c> data(volcano)

flld.c> filled.contour(volcano, color = terrain.colors, asp = 1)

flld.c> x <- 10 * 1:nrow(volcano)

flld.c> y <- 10 * 1:ncol(volcano)

flld.c> filled.contour(x, y, volcano, color = terrain.colors, 
    plot.title = title(main = "The Topography of Maunga Whau", 
        xlab = "Meters North", ylab = "Meters West"), plot.axes = {
        axis(1, seq(100, 800, by = 100))
        axis(2, seq(10 .... [TRUNCATED] 

flld.c> mtext(paste("filled.contour(.) from", R.version.string), 
    side = 1, line = 4, adj = 1, cex = 0.66)

flld.c> a <- expand.grid(1:20, 1:20)

flld.c> b <- matrix(a[, 1] + a[, 2], 20)

flld.c> filled.contour(x = 1:20, y = 1:20, z = b, plot.axes = {
    axis(1)
    axis(2)
    points(10, 10)
})

> par(opar)


	demo(is.things)
	---- ~~~~~~~~~

> ls.base <- ls("package:base")

> base.is.f <- sapply(ls.base, function(x) is.function(get(x)))

> bi <- ls.base[base.is.f]

> cat("\nNumber of base objects:\t\t", length(ls.base), 
    "\nNumber of builtin functions:\t", sum(base.is.f), "\n\t starting with 'is.' :\t ", 
    length(is.bi <- bi[substring(bi, 1, 3) == "is."]), "\n")

Number of base objects:		 1603 
Number of builtin functions:	 1570 
	 starting with 'is.' :	  45 

> is.primitive <- function(obj) is.function(obj) && 
    is.null(args(obj))

> is.method <- function(fname) {
    isFun <- function(name) (exists(name, mode = "function") && 
        is.na(match(name, c("is", "as"))))
    np <- length(sp <- strsplit(fname, split = "\\.")[[1]])
    if (np <= 1) 
        FALSE
    else (isFun(pas .... [TRUNCATED] 

> is.ALL <- function(obj, func.names = ls(pos = length(search())), 
    not.using = c("is.single", "is.loaded", "is.empty.model", 
        "is.R", "is.element"), true.only = FALSE, debug = FALSE) {
    is.fn <- func.names[substring(func.names, 1, 3) == .... [TRUNCATED] 

> print.isList <- function(x, ..., verbose = getOption("verbose")) {
    if (is.list(x)) {
        if (verbose) 
            cat("print.isList(): list case (length=", length(x), 
                ")\n")
        nm <- format(names(x))
        rr <- lappl .... [TRUNCATED] 

> is.ALL(NULL)
is.array       : . 
is.atomic      : | 
is.call        : . 
is.character   : . 
is.complex     : . 
is.data.frame  : . 
is.double      : . 
is.environment : . 
is.expression  : . 
is.factor      : . 
is.finite      : NA 
is.function    : . 
is.infinite    : () 
is.integer     : . 
is.language    : . 
is.list        : . 
is.logical     : . 
is.matrix      : . 
is.mts         : . 
is.na          : NA 
is.name        : . 
is.nan         : () 
is.null        : | 
is.numeric     : . 
is.object      : . 
is.ordered     : . 
is.pairlist    : | 
is.qr          : . 
is.real        : . 
is.recursive   : . 
is.symbol      : . 
is.table       : . 
is.ts          : . 
is.unsorted    : . 
is.vector      : . 

> is.ALL(NULL, true.only = TRUE)
[1] "is.atomic"   "is.null"     "is.pairlist"

> all.equal(NULL, pairlist())
[1] TRUE

> is.ALL(list(), true.only = TRUE)
[1] "is.list"      "is.recursive" "is.vector"   

> (pl <- is.ALL(pairlist(1, list(3, "A")), true.only = TRUE))
[1] "is.list"      "is.pairlist"  "is.recursive"

> (ll <- is.ALL(list(1, pairlist(3, "A")), true.only = TRUE))
[1] "is.list"      "is.recursive" "is.vector"   

> all.equal(pl[pl != "is.pairlist"], ll[ll != "is.vector"])
[1] TRUE

> is.ALL(1:5)
is.array       : . 
is.atomic      : | 
is.call        : . 
is.character   : . 
is.complex     : . 
is.data.frame  : . 
is.double      : . 
is.environment : . 
is.expression  : . 
is.factor      : . 
is.finite      : | | | | | 
is.function    : . 
is.infinite    : . . . . . 
is.integer     : | 
is.language    : . 
is.list        : . 
is.logical     : . 
is.matrix      : . 
is.mts         : . 
is.na          : . . . . . 
is.name        : . 
is.nan         : . . . . . 
is.null        : . 
is.numeric     : | 
is.object      : . 
is.ordered     : . 
is.pairlist    : . 
is.qr          : . 
is.real        : . 
is.recursive   : . 
is.symbol      : . 
is.table       : . 
is.ts          : . 
is.unsorted    : . 
is.vector      : | 

> is.ALL(array(1:24, 2:4))
is.array       : | 
is.atomic      : | 
is.call        : . 
is.character   : . 
is.complex     : . 
is.data.frame  : . 
is.double      : . 
is.environment : . 
is.expression  : . 
is.factor      : . 
is.finite      : | | | | | | | | | | | | | | | | | | | | | | | | 
is.function    : . 
is.infinite    : . . . . . . . . . . . . . . . . . . . . . . . . 
is.integer     : | 
is.language    : . 
is.list        : . 
is.logical     : . 
is.matrix      : . 
is.mts         : . 
is.na          : . . . . . . . . . . . . . . . . . . . . . . . . 
is.name        : . 
is.nan         : . . . . . . . . . . . . . . . . . . . . . . . . 
is.null        : . 
is.numeric     : | 
is.object      : . 
is.ordered     : . 
is.pairlist    : . 
is.qr          : . 
is.real        : . 
is.recursive   : . 
is.symbol      : . 
is.table       : . 
is.ts          : . 
is.unsorted    : . 
is.vector      : . 

> is.ALL(1 + 3)
is.array       : . 
is.atomic      : | 
is.call        : . 
is.character   : . 
is.complex     : . 
is.data.frame  : . 
is.double      : | 
is.environment : . 
is.expression  : . 
is.factor      : . 
is.finite      : | 
is.function    : . 
is.infinite    : . 
is.integer     : . 
is.language    : . 
is.list        : . 
is.logical     : . 
is.matrix      : . 
is.mts         : . 
is.na          : . 
is.name        : . 
is.nan         : . 
is.null        : . 
is.numeric     : | 
is.object      : . 
is.ordered     : . 
is.pairlist    : . 
is.qr          : . 
is.real        : | 
is.recursive   : . 
is.symbol      : . 
is.table       : . 
is.ts          : . 
is.unsorted    : . 
is.vector      : | 

> e13 <- expression(1 + 3)

> is.ALL(e13)
is.array       : . 
is.atomic      : . 
is.call        : . 
is.character   : . 
is.complex     : . 
is.data.frame  : . 
is.double      : . 
is.environment : . 
is.expression  : | 
is.factor      : . 
is.finite      : . 
is.function    : . 
is.infinite    : . 
is.integer     : . 
is.language    : | 
is.list        : . 
is.logical     : . 
is.matrix      : . 
is.mts         : . 
is.na          : . 
is.name        : . 
is.nan         : . 
is.null        : . 
is.numeric     : . 
is.object      : . 
is.ordered     : . 
is.pairlist    : . 
is.qr          : . 
is.real        : . 
is.recursive   : | 
is.symbol      : . 
is.table       : . 
is.ts          : . 
is.unsorted    : NA 
is.vector      : | 

> is.ALL(substitute(expression(a + 3), list(a = 1)), 
    true.only = TRUE)
[1] "is.call"      "is.language"  "is.recursive"

> is.ALL(y ~ x)
is.array       : . 
is.atomic      : . 
is.call        : | 
is.character   : . 
is.complex     : . 
is.data.frame  : . 
is.double      : . 
is.environment : . 
is.expression  : . 
is.factor      : . 
is.finite      : NA 
is.function    : . 
is.infinite    : . . . 
is.integer     : . 
is.language    : | 
is.list        : . 
is.logical     : . 
is.matrix      : . 
is.mts         : . 
is.na          : NA 
is.name        : . 
is.nan         : . . . 
is.null        : . 
is.numeric     : . 
is.object      : | 
is.ordered     : . 
is.pairlist    : . 
is.qr          : . 
is.real        : . 
is.recursive   : | 
is.symbol      : . 
is.table       : . 
is.ts          : . 
is.unsorted    : NA 
is.vector      : . 

> is0 <- is.ALL(numeric(0))

> is0.ok <- 1 == (lis0 <- sapply(is0, length))

> is0[!is0.ok]
$is.finite
logical(0)

$is.infinite
logical(0)

$is.na
logical(0)

$is.nan
logical(0)


> is0 <- unlist(is0)

> is0
      is.array      is.atomic        is.call   is.character     is.complex 
         FALSE           TRUE          FALSE          FALSE          FALSE 
 is.data.frame      is.double is.environment  is.expression      is.factor 
         FALSE           TRUE          FALSE          FALSE          FALSE 
   is.function     is.integer    is.language        is.list     is.logical 
         FALSE          FALSE          FALSE          FALSE          FALSE 
     is.matrix         is.mts        is.name        is.null     is.numeric 
         FALSE          FALSE          FALSE          FALSE           TRUE 
     is.object     is.ordered    is.pairlist          is.qr        is.real 
         FALSE          FALSE          FALSE          FALSE           TRUE 
  is.recursive      is.symbol       is.table          is.ts    is.unsorted 
         FALSE          FALSE          FALSE          FALSE          FALSE 
     is.vector 
          TRUE 

> ispi <- unlist(is.ALL(pi))

> all(ispi[is0.ok] == is0)
[1] TRUE

> is.ALL(numeric(0), true = TRUE)
[1] "is.atomic"  "is.double"  "is.numeric" "is.real"    "is.vector" 

> is.ALL(array(1, 1:3), true = TRUE)
[1] "is.array"   "is.atomic"  "is.double"  "is.numeric" "is.real"   

> is.ALL(cbind(1:3), true = TRUE)
[1] "is.array"   "is.atomic"  "is.integer" "is.matrix"  "is.numeric"

> is.ALL(structure(1:7, names = paste("a", 1:7, sep = "")))
is.array       : . 
is.atomic      : | 
is.call        : . 
is.character   : . 
is.complex     : . 
is.data.frame  : . 
is.double      : . 
is.environment : . 
is.expression  : . 
is.factor      : . 
is.finite      : | | | | | | | 
is.function    : . 
is.infinite    : . . . . . . . 
is.integer     : | 
is.language    : . 
is.list        : . 
is.logical     : . 
is.matrix      : . 
is.mts         : . 
is.na          : . . . . . . . 
is.name        : . 
is.nan         : . . . . . . . 
is.null        : . 
is.numeric     : | 
is.object      : . 
is.ordered     : . 
is.pairlist    : . 
is.qr          : . 
is.real        : . 
is.recursive   : . 
is.symbol      : . 
is.table       : . 
is.ts          : . 
is.unsorted    : . 
is.vector      : | 

> is.ALL(structure(1:7, names = paste("a", 1:7, sep = "")), 
    true.only = TRUE)
[1] "is.atomic"  "is.integer" "is.numeric" "is.vector" 

> x <- 1:20

> y <- 5 + 6 * x + rnorm(20)

> lm.xy <- lm(y ~ x)

> is.ALL(lm.xy)
is.array       : . 
is.atomic      : . 
is.call        : . 
is.character   : . 
is.complex     : . 
is.data.frame  : . 
is.double      : . 
is.environment : . 
is.expression  : . 
is.factor      : . 
is.finite      : . . . . . . . . . . . . 
is.function    : . 
is.infinite    : . . . . . . . . . . . . 
is.integer     : . 
is.language    : . 
is.list        : | 
is.logical     : . 
is.matrix      : . 
is.mts         : . 
is.na          : . . . . . . . . . . . . 
is.name        : . 
is.nan         : . . . . . . . . . . . . 
is.null        : . 
is.numeric     : . 
is.object      : | 
is.ordered     : . 
is.pairlist    : . 
is.qr          : . 
is.real        : . 
is.recursive   : | 
is.symbol      : . 
is.table       : . 
is.ts          : . 
is.unsorted    : NA 
is.vector      : . 

> is.ALL(structure(1:7, names = paste("a", 1:7, sep = "")))
is.array       : . 
is.atomic      : | 
is.call        : . 
is.character   : . 
is.complex     : . 
is.data.frame  : . 
is.double      : . 
is.environment : . 
is.expression  : . 
is.factor      : . 
is.finite      : | | | | | | | 
is.function    : . 
is.infinite    : . . . . . . . 
is.integer     : | 
is.language    : . 
is.list        : . 
is.logical     : . 
is.matrix      : . 
is.mts         : . 
is.na          : . . . . . . . 
is.name        : . 
is.nan         : . . . . . . . 
is.null        : . 
is.numeric     : | 
is.object      : . 
is.ordered     : . 
is.pairlist    : . 
is.qr          : . 
is.real        : . 
is.recursive   : . 
is.symbol      : . 
is.table       : . 
is.ts          : . 
is.unsorted    : . 
is.vector      : | 

> is.ALL(structure(1:7, names = paste("a", 1:7, sep = "")), 
    true.only = TRUE)
[1] "is.atomic"  "is.integer" "is.numeric" "is.vector" 


	demo(lm.glm)
	---- ~~~~~~

> ctl <- c(4.17, 5.58, 5.18, 6.11, 4.5, 4.61, 5.17, 
    4.53, 5.33, 5.14)

> trt <- c(4.81, 4.17, 4.41, 3.59, 5.87, 3.83, 6.03, 
    4.89, 4.32, 4.69)

> group <- gl(2, 10, labels = c("Ctl", "Trt"))

> weight <- c(ctl, trt)

> anova(lm(weight ~ group))
Analysis of Variance Table

Response: weight
          Df Sum Sq Mean Sq F value Pr(>F)
group      1 0.6882  0.6882  1.4191  0.249
Residuals 18 8.7293  0.4850               

> summary(lm(weight ~ group - 1))

Call:
lm(formula = weight ~ group - 1)

Residuals:
    Min      1Q  Median      3Q     Max 
-1.0710 -0.4938  0.0685  0.2462  1.3690 

Coefficients:
         Estimate Std. Error t value Pr(>|t|)    
groupCtl   5.0320     0.2202   22.85 9.55e-15 ***
groupTrt   4.6610     0.2202   21.16 3.62e-14 ***
---
Signif. codes:  0 `***' 0.001 `**' 0.01 `*' 0.05 `.' 0.1 ` ' 1 

Residual standard error: 0.6964 on 18 degrees of freedom
Multiple R-Squared: 0.9818,	Adjusted R-squared: 0.9798 
F-statistic: 485.1 on 2 and 18 DF,  p-value: < 2.2e-16 


> age <- c(40, 38, 40, 35, 36, 37, 41, 40, 37, 38, 40, 
    38, 40, 36, 40, 38, 42, 39, 40, 37, 36, 38, 39, 40)

> birthw <- c(2968, 2795, 3163, 2925, 2625, 2847, 3292, 
    3473, 2628, 3176, 3421, 2975, 3317, 2729, 2935, 2754, 3210, 
    2817, 3126, 2539, 2412, 2991, 2875, 3231)

> sex <- gl(2, 12, labels = c("M", "F"))

> if (!is.null(dev.list())) {
    plot(age, birthw, col = codes(sex), main = "Dobson's Birth Weight Data")
    lines(lowess(age[sex == "F"], birthw[sex == "F"]), col = 1)
    lines(lowess(age[sex == "M"], birthw[sex == "M"]), col = 2)
    legend(40, 27 .... [TRUNCATED] 

> summary(l1 <- lm(birthw ~ sex + age), cor = TRUE)

Call:
lm(formula = birthw ~ sex + age)

Residuals:
    Min      1Q  Median      3Q     Max 
-257.49 -125.28  -58.44  169.00  303.98 

Coefficients:
            Estimate Std. Error t value Pr(>|t|)    
(Intercept) -1610.28     786.08  -2.049   0.0532 .  
sexF         -163.04      72.81  -2.239   0.0361 *  
age           120.89      20.46   5.908 7.28e-06 ***
---
Signif. codes:  0 `***' 0.001 `**' 0.01 `*' 0.05 `.' 0.1 ` ' 1 

Residual standard error: 177.1 on 21 degrees of freedom
Multiple R-Squared:  0.64,	Adjusted R-squared: 0.6057 
F-statistic: 18.67 on 2 and 21 DF,  p-value: 2.194e-05 

Correlation of Coefficients:
     (Intercept)    sexF
sexF     0.07118        
age     -0.99788 -0.1171


> summary(l0 <- lm(birthw ~ sex + age - 1), cor = TRUE)

Call:
lm(formula = birthw ~ sex + age - 1)

Residuals:
    Min      1Q  Median      3Q     Max 
-257.49 -125.28  -58.44  169.00  303.98 

Coefficients:
     Estimate Std. Error t value Pr(>|t|)    
sexM -1610.28     786.08  -2.049   0.0532 .  
sexF -1773.32     794.59  -2.232   0.0367 *  
age    120.89      20.46   5.908 7.28e-06 ***
---
Signif. codes:  0 `***' 0.001 `**' 0.01 `*' 0.05 `.' 0.1 ` ' 1 

Residual standard error: 177.1 on 21 degrees of freedom
Multiple R-Squared: 0.9969,	Adjusted R-squared: 0.9965 
F-statistic:  2258 on 3 and 21 DF,  p-value: < 2.2e-16 

Correlation of Coefficients:
        sexM   sexF
sexF  0.9958       
age  -0.9979 -0.998


> anova(l1, l0)
Analysis of Variance Table

Model 1: birthw ~ sex + age
Model 2: birthw ~ sex + age - 1
  Res.Df    RSS Df  Sum of Sq F Pr(>F)
1     21 658771                       
2     21 658771  0 -4.657e-10         

> summary(li <- lm(birthw ~ sex + sex:age - 1), cor = TRUE)

Call:
lm(formula = birthw ~ sex + sex:age - 1)

Residuals:
    Min      1Q  Median      3Q     Max 
-246.69 -138.11  -39.13  176.57  274.28 

Coefficients:
         Estimate Std. Error t value Pr(>|t|)    
sexM     -1268.67    1114.64  -1.138 0.268492    
sexF     -2141.67    1163.60  -1.841 0.080574 .  
sexM:age   111.98      29.05   3.855 0.000986 ***
sexF:age   130.40      30.00   4.347 0.000313 ***
---
Signif. codes:  0 `***' 0.001 `**' 0.01 `*' 0.05 `.' 0.1 ` ' 1 

Residual standard error: 180.6 on 20 degrees of freedom
Multiple R-Squared: 0.9969,	Adjusted R-squared: 0.9963 
F-statistic:  1629 on 4 and 20 DF,  p-value: < 2.2e-16 

Correlation of Coefficients:
               sexM       sexF  sexM:age
sexF      7.640e-16                     
sexM:age -9.989e-01 -7.648e-16          
sexF:age -7.647e-16 -9.990e-01 7.656e-16


> anova(li, l0)
Analysis of Variance Table

Model 1: birthw ~ sex + sex:age - 1
Model 2: birthw ~ sex + age - 1
  Res.Df    RSS Df Sum of Sq      F Pr(>F)
1     20 652425                           
2     21 658771 -1     -6346 0.1945 0.6639

> summary(zi <- glm(birthw ~ sex + age, family = gaussian()))

Call:
glm(formula = birthw ~ sex + age, family = gaussian())

Deviance Residuals: 
    Min       1Q   Median       3Q      Max  
-257.49  -125.28   -58.44   169.00   303.98  

Coefficients:
            Estimate Std. Error t value Pr(>|t|)    
(Intercept) -1610.28     786.08  -2.049   0.0532 .  
sexF         -163.04      72.81  -2.239   0.0361 *  
age           120.89      20.46   5.908 7.28e-06 ***
---
Signif. codes:  0 `***' 0.001 `**' 0.01 `*' 0.05 `.' 0.1 ` ' 1 

(Dispersion parameter for gaussian family taken to be 31370.04)

    Null deviance: 1829873  on 23  degrees of freedom
Residual deviance:  658771  on 21  degrees of freedom
AIC: 321.39

Number of Fisher Scoring iterations: 2


> summary(z0 <- glm(birthw ~ sex + age - 1, family = gaussian()))

Call:
glm(formula = birthw ~ sex + age - 1, family = gaussian())

Deviance Residuals: 
    Min       1Q   Median       3Q      Max  
-257.49  -125.28   -58.44   169.00   303.98  

Coefficients:
     Estimate Std. Error t value Pr(>|t|)    
sexM -1610.28     786.08  -2.049   0.0532 .  
sexF -1773.32     794.59  -2.232   0.0367 *  
age    120.89      20.46   5.908 7.28e-06 ***
---
Signif. codes:  0 `***' 0.001 `**' 0.01 `*' 0.05 `.' 0.1 ` ' 1 

(Dispersion parameter for gaussian family taken to be 31370.04)

    Null deviance: 213198964  on 24  degrees of freedom
Residual deviance:    658771  on 21  degrees of freedom
AIC: 321.39

Number of Fisher Scoring iterations: 2


> anova(zi, z0)
Analysis of Deviance Table

Model 1: birthw ~ sex + age
Model 2: birthw ~ sex + age - 1
  Resid. Df Resid. Dev Df   Deviance
1        21     658771              
2        21     658771  0 -1.164e-10

> summary(z.o4 <- update(z0, subset = -4))

Call:
glm(formula = birthw ~ sex + age - 1, family = gaussian(), subset = -4)

Deviance Residuals: 
    Min       1Q   Median       3Q      Max  
-253.86  -129.46   -53.46   165.04   251.14  

Coefficients:
     Estimate Std. Error t value Pr(>|t|)    
sexM -2318.03     801.57  -2.892  0.00902 ** 
sexF -2455.44     803.79  -3.055  0.00625 ** 
age    138.50      20.71   6.688 1.65e-06 ***
---
Signif. codes:  0 `***' 0.001 `**' 0.01 `*' 0.05 `.' 0.1 ` ' 1 

(Dispersion parameter for gaussian family taken to be 26925.39)

    Null deviance: 204643339  on 23  degrees of freedom
Residual deviance:    538508  on 20  degrees of freedom
AIC: 304.68

Number of Fisher Scoring iterations: 2


> summary(zz <- update(z0, birthw ~ sex + age - 1 + 
    sex:age))

Call:
glm(formula = birthw ~ sex + age + sex:age - 1, family = gaussian())

Deviance Residuals: 
    Min       1Q   Median       3Q      Max  
-246.69  -138.11   -39.13   176.57   274.28  

Coefficients:
         Estimate Std. Error t value Pr(>|t|)    
sexM     -1268.67    1114.64  -1.138 0.268492    
sexF     -2141.67    1163.60  -1.841 0.080574 .  
age        111.98      29.05   3.855 0.000986 ***
sexF:age    18.42      41.76   0.441 0.663893    
---
Signif. codes:  0 `***' 0.001 `**' 0.01 `*' 0.05 `.' 0.1 ` ' 1 

(Dispersion parameter for gaussian family taken to be 32621.23)

    Null deviance: 213198964  on 24  degrees of freedom
Residual deviance:    652425  on 20  degrees of freedom
AIC: 323.16

Number of Fisher Scoring iterations: 2


> anova(z0, zz)
Analysis of Deviance Table

Model 1: birthw ~ sex + age - 1
Model 2: birthw ~ sex + age + sex:age - 1
  Resid. Df Resid. Dev Df Deviance
1        21     658771            
2        20     652425  1     6346

> x <- c(-1, -1, 0, 0, 0, 0, 1, 1, 1)

> y <- c(2, 3, 6, 7, 8, 9, 10, 12, 15)

> summary(glm(y ~ x, family = poisson(link = "identity")))

Call:
glm(formula = y ~ x, family = poisson(link = "identity"))

Deviance Residuals: 
    Min       1Q   Median       3Q      Max  
-0.7019  -0.3377  -0.1105   0.2958   0.7184  

Coefficients:
            Estimate Std. Error z value Pr(>|z|)    
(Intercept)   7.4516     0.8841   8.428  < 2e-16 ***
x             4.9353     1.0892   4.531 5.86e-06 ***
---
Signif. codes:  0 `***' 0.001 `**' 0.01 `*' 0.05 `.' 0.1 ` ' 1 

(Dispersion parameter for poisson family taken to be 1)

    Null deviance: 18.4206  on 8  degrees of freedom
Residual deviance:  1.8947  on 7  degrees of freedom
AIC: 40.008

Number of Fisher Scoring iterations: 3


> calorie <- data.frame(carb = c(33, 40, 37, 27, 30, 
    43, 34, 48, 30, 38, 50, 51, 30, 36, 41, 42, 46, 24, 35, 37), 
    age = c(33, 47, 49, 35, 46, 52, 62, 23, 32, 42, 31, 61, 63, 
        40, 50, 64, 56, 61, 48, 28), wgt = c(100, 92, 135, 144, 
   .... [TRUNCATED] 

> summary(lmcal <- lm(carb ~ age + wgt + prot, data = calorie))

Call:
lm(formula = carb ~ age + wgt + prot, data = calorie)

Residuals:
     Min       1Q   Median       3Q      Max 
-10.3424  -4.8203   0.9897   3.8553   7.9087 

Coefficients:
            Estimate Std. Error t value Pr(>|t|)   
(Intercept) 36.96006   13.07128   2.828  0.01213 * 
age         -0.11368    0.10933  -1.040  0.31389   
wgt         -0.22802    0.08329  -2.738  0.01460 * 
prot         1.95771    0.63489   3.084  0.00712 **
---
Signif. codes:  0 `***' 0.001 `**' 0.01 `*' 0.05 `.' 0.1 ` ' 1 

Residual standard error: 5.956 on 16 degrees of freedom
Multiple R-Squared: 0.4805,	Adjusted R-squared: 0.3831 
F-statistic: 4.934 on 3 and 16 DF,  p-value: 0.01297 


> ctl <- c(4.17, 5.58, 5.18, 6.11, 4.5, 4.61, 5.17, 
    4.53, 5.33, 5.14)

> trtA <- c(4.81, 4.17, 4.41, 3.59, 5.87, 3.83, 6.03, 
    4.89, 4.32, 4.69)

> trtB <- c(6.31, 5.12, 5.54, 5.5, 5.37, 5.29, 4.92, 
    6.15, 5.8, 5.26)

> group <- gl(3, length(ctl), labels = c("Ctl", "A", 
    "B"))

> weight <- c(ctl, trtA, trtB)

> anova(lmwg <- lm(weight ~ group))
Analysis of Variance Table

Response: weight
          Df  Sum Sq Mean Sq F value  Pr(>F)  
group      2  3.7663  1.8832  4.8461 0.01591 *
Residuals 27 10.4921  0.3886                  
---
Signif. codes:  0 `***' 0.001 `**' 0.01 `*' 0.05 `.' 0.1 ` ' 1 

> summary(lmwg)

Call:
lm(formula = weight ~ group)

Residuals:
    Min      1Q  Median      3Q     Max 
-1.0710 -0.4180 -0.0060  0.2627  1.3690 

Coefficients:
            Estimate Std. Error t value Pr(>|t|)    
(Intercept)   5.0320     0.1971  25.527   <2e-16 ***
groupA       -0.3710     0.2788  -1.331   0.1944    
groupB        0.4940     0.2788   1.772   0.0877 .  
---
Signif. codes:  0 `***' 0.001 `**' 0.01 `*' 0.05 `.' 0.1 ` ' 1 

Residual standard error: 0.6234 on 27 degrees of freedom
Multiple R-Squared: 0.2641,	Adjusted R-squared: 0.2096 
F-statistic: 4.846 on 2 and 27 DF,  p-value: 0.01591 


> coef(lmwg)
(Intercept)      groupA      groupB 
      5.032      -0.371       0.494 

> coef(summary(lmwg))
            Estimate Std. Error   t value     Pr(>|t|)
(Intercept)    5.032  0.1971284 25.526514 1.936575e-20
groupA        -0.371  0.2787816 -1.330791 1.943879e-01
groupB         0.494  0.2787816  1.771996 8.768168e-02

> y <- c(6.8, 6.6, 5.3, 6.1, 7.5, 7.4, 7.2, 6.5, 7.8, 
    9.1, 8.8, 9.1)

> a <- gl(3, 4)

> b <- gl(2, 2, length(a))

> anova(z <- lm(y ~ a * b))
Analysis of Variance Table

Response: y
          Df  Sum Sq Mean Sq F value   Pr(>F)   
a          2 12.7400  6.3700 25.8243 0.001127 **
b          1  0.4033  0.4033  1.6351 0.248225   
a:b        2  1.2067  0.6033  2.4459 0.167164   
Residuals  6  1.4800  0.2467                    
---
Signif. codes:  0 `***' 0.001 `**' 0.01 `*' 0.05 `.' 0.1 ` ' 1 

> y <- c(6, 4, 5, 3, 4, 3, 6, 8, 9, 7, 9, 8, 5, 7, 6, 
    7, 7, 7, 8, 5, 7)

> x <- c(3, 1, 3, 1, 2, 1, 4, 4, 5, 5, 4, 3, 1, 2, 3, 
    2, 2, 3, 4, 1, 4)

> m <- gl(3, 7)

> anova(z <- lm(y ~ x + m))
Analysis of Variance Table

Response: y
          Df Sum Sq Mean Sq F value    Pr(>F)    
x          1 36.575  36.575  60.355 5.428e-07 ***
m          2 16.932   8.466  13.970 0.0002579 ***
Residuals 17 10.302   0.606                      
---
Signif. codes:  0 `***' 0.001 `**' 0.01 `*' 0.05 `.' 0.1 ` ' 1 

> dose <- c(1.6907, 1.7242, 1.7552, 1.7842, 1.8113, 
    1.8369, 1.861, 1.8839)

> x <- c(6, 13, 18, 28, 52, 53, 61, 60)

> n <- c(59, 60, 62, 56, 63, 59, 62, 60)

> dead <- cbind(x, n - x)

> summary(glm(dead ~ dose, family = binomial(link = logit)))

Call:
glm(formula = dead ~ dose, family = binomial(link = logit))

Deviance Residuals: 
    Min       1Q   Median       3Q      Max  
-1.5941  -0.3944   0.8329   1.2592   1.5940  

Coefficients:
            Estimate Std. Error z value Pr(>|z|)    
(Intercept)  -60.717      5.173  -11.74   <2e-16 ***
dose          34.270      2.908   11.79   <2e-16 ***
---
Signif. codes:  0 `***' 0.001 `**' 0.01 `*' 0.05 `.' 0.1 ` ' 1 

(Dispersion parameter for binomial family taken to be 1)

    Null deviance: 284.202  on 7  degrees of freedom
Residual deviance:  11.232  on 6  degrees of freedom
AIC: 41.43

Number of Fisher Scoring iterations: 3


> summary(glm(dead ~ dose, family = binomial(link = probit)))

Call:
glm(formula = dead ~ dose, family = binomial(link = probit))

Deviance Residuals: 
    Min       1Q   Median       3Q      Max  
-1.5714  -0.4702   0.7501   1.0632   1.3448  

Coefficients:
            Estimate Std. Error z value Pr(>|z|)    
(Intercept)  -34.935      2.648  -13.19   <2e-16 ***
dose          19.728      1.487   13.27   <2e-16 ***
---
Signif. codes:  0 `***' 0.001 `**' 0.01 `*' 0.05 `.' 0.1 ` ' 1 

(Dispersion parameter for binomial family taken to be 1)

    Null deviance: 284.202  on 7  degrees of freedom
Residual deviance:  10.120  on 6  degrees of freedom
AIC: 40.318

Number of Fisher Scoring iterations: 3


> summary(z <- glm(dead ~ dose, family = binomial(link = cloglog)))

Call:
glm(formula = dead ~ dose, family = binomial(link = cloglog))

Deviance Residuals: 
     Min        1Q    Median        3Q       Max  
-0.80327  -0.55136   0.03090   0.38315   1.28883  

Coefficients:
            Estimate Std. Error z value Pr(>|z|)    
(Intercept)  -39.573      3.237  -12.23   <2e-16 ***
dose          22.041      1.797   12.26   <2e-16 ***
---
Signif. codes:  0 `***' 0.001 `**' 0.01 `*' 0.05 `.' 0.1 ` ' 1 

(Dispersion parameter for binomial family taken to be 1)

    Null deviance: 284.2024  on 7  degrees of freedom
Residual deviance:   3.4464  on 6  degrees of freedom
AIC: 33.644

Number of Fisher Scoring iterations: 3


> anova(z, update(z, dead ~ dose - 1))
Analysis of Deviance Table

Model 1: dead ~ dose
Model 2: dead ~ dose - 1
  Resid. Df Resid. Dev Df Deviance
1         6      3.446            
2         7    285.222 -1 -281.776

> n <- c(102, 99, 108, 76, 81, 90)

> p <- c(0.539, 0.525, 0.528, 0.724, 0.617, 0.555)

> x <- round(n * p)

> y <- cbind(x, n - x)

> f <- rep(c(40, 150, 350), 2)

> (g <- gl(2, 3))
[1] 1 1 1 2 2 2
Levels: 1 2

> summary(glm(y ~ g * f, family = binomial(link = "logit")))

Call:
glm(formula = y ~ g * f, family = binomial(link = "logit"))

Deviance Residuals: 
[1]   0.08269  -0.12998   0.04414   0.42320  -0.60082   0.19522

Coefficients:
              Estimate Std. Error z value Pr(>|z|)  
(Intercept)  0.1456719  0.1975451   0.737   0.4609  
g2           0.7963143  0.3125046   2.548   0.0108 *
f           -0.0001227  0.0008782  -0.140   0.8889  
g2:f        -0.0020493  0.0013483  -1.520   0.1285  
---
Signif. codes:  0 `***' 0.001 `**' 0.01 `*' 0.05 `.' 0.1 ` ' 1 

(Dispersion parameter for binomial family taken to be 1)

    Null deviance: 10.45197  on 5  degrees of freedom
Residual deviance:  0.60387  on 2  degrees of freedom
AIC: 38.172

Number of Fisher Scoring iterations: 3


> summary(glm(y ~ g + f, family = binomial(link = "logit")))

Call:
glm(formula = y ~ g + f, family = binomial(link = "logit"))

Deviance Residuals: 
[1]  -0.5507  -0.2781   0.7973   1.1558  -0.3688  -0.6584

Coefficients:
             Estimate Std. Error z value Pr(>|z|)  
(Intercept)  0.306643   0.167629   1.829   0.0674 .
g2           0.405554   0.174560   2.323   0.0202 *
f           -0.000997   0.000665  -1.499   0.1338  
---
Signif. codes:  0 `***' 0.001 `**' 0.01 `*' 0.05 `.' 0.1 ` ' 1 

(Dispersion parameter for binomial family taken to be 1)

    Null deviance: 10.4520  on 5  degrees of freedom
Residual deviance:  2.9218  on 3  degrees of freedom
AIC: 38.49

Number of Fisher Scoring iterations: 3


> summary(glm.p84 <- glm(y ~ g, family = binomial(link = "logit")))

Call:
glm(formula = y ~ g, family = binomial(link = "logit"))

Deviance Residuals: 
[1]   0.17150  -0.10947  -0.06177   1.77208  -0.19040  -1.39686

Coefficients:
            Estimate Std. Error z value Pr(>|z|)  
(Intercept)   0.1231     0.1140   1.080   0.2801  
g2            0.3985     0.1741   2.289   0.0221 *
---
Signif. codes:  0 `***' 0.001 `**' 0.01 `*' 0.05 `.' 0.1 ` ' 1 

(Dispersion parameter for binomial family taken to be 1)

    Null deviance: 10.452  on 5  degrees of freedom
Residual deviance:  5.173  on 4  degrees of freedom
AIC: 38.741

Number of Fisher Scoring iterations: 3


> op <- par(mfrow = c(2, 2), oma = c(0, 0, 1, 0))

> plot(glm.p84)

> par(op)

> counts <- c(22, 2, 10, 16, 54, 115, 19, 33, 73, 11, 
    17, 28)

> type <- gl(4, 3, 12, labels = c("freckle", "superficial", 
    "nodular", "indeterminate"))

> site <- gl(3, 1, 12, labels = c("head/neck", "trunk", 
    "extremities"))

> data.frame(counts, type, site)
   counts          type        site
1      22       freckle   head/neck
2       2       freckle       trunk
3      10       freckle extremities
4      16   superficial   head/neck
5      54   superficial       trunk
6     115   superficial extremities
7      19       nodular   head/neck
8      33       nodular       trunk
9      73       nodular extremities
10     11 indeterminate   head/neck
11     17 indeterminate       trunk
12     28 indeterminate extremities

> summary(z <- glm(counts ~ type + site, family = poisson()))

Call:
glm(formula = counts ~ type + site, family = poisson())

Deviance Residuals: 
    Min       1Q   Median       3Q      Max  
-3.0453  -1.0741   0.1297   0.5857   5.1353  

Coefficients:
                  Estimate Std. Error z value Pr(>|z|)    
(Intercept)         1.7544     0.2035   8.622  < 2e-16 ***
typesuperficial     1.6940     0.1860   9.105  < 2e-16 ***
typenodular         1.3019     0.1929   6.749 1.48e-11 ***
typeindeterminate   0.4990     0.2169   2.300  0.02145 *  
sitetrunk           0.4439     0.1553   2.858  0.00426 ** 
siteextremities     1.2010     0.1383   8.686  < 2e-16 ***
---
Signif. codes:  0 `***' 0.001 `**' 0.01 `*' 0.05 `.' 0.1 ` ' 1 

(Dispersion parameter for poisson family taken to be 1)

    Null deviance: 295.203  on 11  degrees of freedom
Residual deviance:  51.795  on  6  degrees of freedom
AIC: 122.91

Number of Fisher Scoring iterations: 4


> counts <- c(18, 17, 15, 20, 10, 20, 25, 13, 12)

> outcome <- gl(3, 1, length(counts))

> treatment <- gl(3, 3)

> summary(z <- glm(counts ~ outcome + treatment, family = poisson()))

Call:
glm(formula = counts ~ outcome + treatment, family = poisson())

Deviance Residuals: 
       1         2         3         4         5         6         7         8  
-0.67125   0.96272  -0.16965  -0.21999  -0.95552   1.04939   0.84715  -0.09167  
       9  
-0.96656  

Coefficients:
              Estimate Std. Error  z value Pr(>|z|)    
(Intercept)  3.045e+00  1.709e-01   17.815   <2e-16 ***
outcome2    -4.543e-01  2.022e-01   -2.247   0.0246 *  
outcome3    -2.930e-01  1.927e-01   -1.520   0.1285    
treatment2   1.924e-08  2.000e-01 9.62e-08   1.0000    
treatment3   8.383e-09  2.000e-01 4.19e-08   1.0000    
---
Signif. codes:  0 `***' 0.001 `**' 0.01 `*' 0.05 `.' 0.1 ` ' 1 

(Dispersion parameter for poisson family taken to be 1)

    Null deviance: 10.5814  on 8  degrees of freedom
Residual deviance:  5.1291  on 4  degrees of freedom
AIC: 56.761

Number of Fisher Scoring iterations: 3


> counts <- c(579, 4219, 911, 4578, 246, 3775, 361, 
    4532, 291, 5261, 396, 6598)

> group <- gl(2, 1, 12, labels = c("cases", "controls"))

> blood <- gl(2, 2, 12, labels = c("A", "O"))

> city <- gl(3, 4, 12, labels = c("London", "Manchester", 
    "Newcastle"))

> cbind(group, blood, city, counts)
      group blood city counts
 [1,]     1     1    1    579
 [2,]     2     1    1   4219
 [3,]     1     2    1    911
 [4,]     2     2    1   4578
 [5,]     1     1    2    246
 [6,]     2     1    2   3775
 [7,]     1     2    2    361
 [8,]     2     2    2   4532
 [9,]     1     1    3    291
[10,]     2     1    3   5261
[11,]     1     2    3    396
[12,]     2     2    3   6598

> summary(z1 <- glm(counts ~ group * (city + blood), 
    family = poisson()))

Call:
glm(formula = counts ~ group * (city + blood), family = poisson())

Deviance Residuals: 
      1        2        3        4        5        6        7        8  
-0.7520   3.0183   0.6099  -2.8137   0.1713  -0.4339  -0.1405   0.3977  
      9       10       11       12  
 0.9318  -2.2691  -0.7742   2.0648  

Coefficients:
                             Estimate Std. Error z value Pr(>|z|)    
(Intercept)                   6.39239    0.03476  183.92  < 2e-16 ***
groupcontrols                 1.90813    0.03691   51.69  < 2e-16 ***
cityManchester               -0.89800    0.04815  -18.65  < 2e-16 ***
cityNewcastle                -0.77420    0.04612  -16.79  < 2e-16 ***
bloodO                        0.40187    0.03867   10.39  < 2e-16 ***
groupcontrols:cityManchester  0.84069    0.05052   16.64  < 2e-16 ***
groupcontrols:cityNewcastle   1.07287    0.04822   22.25  < 2e-16 ***
groupcontrols:bloodO         -0.23208    0.04043   -5.74 9.46e-09 ***
---
Signif. codes:  0 `***' 0.001 `**' 0.01 `*' 0.05 `.' 0.1 ` ' 1 

(Dispersion parameter for poisson family taken to be 1)

    Null deviance: 26717.157  on 11  degrees of freedom
Residual deviance:    29.241  on  4  degrees of freedom
AIC: 154.32

Number of Fisher Scoring iterations: 3


> summary(z2 <- glm(counts ~ group * city + blood, family = poisson()), 
    corr = TRUE)

Call:
glm(formula = counts ~ group * city + blood, family = poisson())

Deviance Residuals: 
      1        2        3        4        5        6        7        8  
-3.7688   3.7168   3.2813  -3.4418  -1.7675   0.2387   1.5565  -0.2174  
      9       10       11       12  
-1.1458  -1.4687   1.0218   1.3275  

Coefficients:
                             Estimate Std. Error z value Pr(>|z|)    
(Intercept)                   6.51395    0.02663  244.60   <2e-16 ***
groupcontrols                 1.77563    0.02801   63.38   <2e-16 ***
cityManchester               -0.89800    0.04815  -18.65   <2e-16 ***
cityNewcastle                -0.77420    0.04612  -16.79   <2e-16 ***
bloodO                        0.18988    0.01128   16.84   <2e-16 ***
groupcontrols:cityManchester  0.84069    0.05052   16.64   <2e-16 ***
groupcontrols:cityNewcastle   1.07287    0.04822   22.25   <2e-16 ***
---
Signif. codes:  0 `***' 0.001 `**' 0.01 `*' 0.05 `.' 0.1 ` ' 1 

(Dispersion parameter for poisson family taken to be 1)

    Null deviance: 26717.157  on 11  degrees of freedom
Residual deviance:    62.558  on  5  degrees of freedom
AIC: 185.63

Number of Fisher Scoring iterations: 3

Correlation of Coefficients:
                             ( gr cM cN b g:M
groupcontrols                + 1             
cityManchester               . .  1          
cityNewcastle                . .  .  1       
bloodO                                  1    
groupcontrols:cityManchester . .  B       1  
groupcontrols:cityNewcastle  . .     B    .  
attr(,"legend")
[1] 0 ` ' 0.3 `.' 0.6 `,' 0.8 `+' 0.9 `*' 0.95 `B' 1


> anova(z2, z1, test = "Chisq")
Analysis of Deviance Table

Model 1: counts ~ group * city + blood
Model 2: counts ~ group * (city + blood)
  Resid. Df Resid. Dev Df Deviance P(>|Chi|)
1         5     62.558                      
2         4     29.241  1   33.318 7.827e-09


	demo(persp)
	---- ~~~~~

> is.dev.interactive <- eval(body(dev.interactive)[[3]])

> op <- par(ask = is.dev.interactive)

> x <- seq(-10, 10, length = 50)

> y <- x

> rotsinc <- function(x, y) {
    sinc <- function(x) {
        y <- sin(x)/x
        y[is.na(y)] <- 1
        y
    }
    10 * sinc(sqrt(x^2 + y^2))
}

> sinc.exp <- expression(z == Sinc(sqrt(x^2 + y^2)))

> z <- outer(x, y, rotsinc)

> par(bg = "white")

> persp(x, y, z, theta = 30, phi = 30, expand = 0.5, 
    col = "lightblue")

> title(sub = ".")

> title(main = sinc.exp)

> persp(x, y, z, theta = 30, phi = 30, expand = 0.5, 
    col = "lightblue", ltheta = 120, shade = 0.75, ticktype = "detailed", 
    xlab = "X", ylab = "Y", zlab = "Z")

> title(sub = ".")

> title(main = sinc.exp)

> data(volcano)

> z <- 2 * volcano

> x <- 10 * (1:nrow(z))

> y <- 10 * (1:ncol(z))

> persp(x, y, z, theta = 120, phi = 15, scale = FALSE, 
    axes = FALSE)

> z0 <- min(z) - 20

> z <- rbind(z0, cbind(z0, z, z0), z0)

> x <- c(min(x) - 1e-10, x, max(x) + 1e-10)

> y <- c(min(y) - 1e-10, y, max(y) + 1e-10)

> fill <- matrix("green3", nr = nrow(z) - 1, nc = ncol(z) - 
    1)

> fill[, i2 <- c(1, ncol(fill))] <- "gray"

> fill[i1 <- c(1, nrow(fill)), ] <- "gray"

> par(bg = "lightblue")

> persp(x, y, z, theta = 120, phi = 15, col = fill, 
    scale = FALSE, axes = FALSE)

> title(main = "Maunga Whau\nOne of 50 Volcanoes in the Auckland Region.", 
    font.main = 4)

> par(bg = "slategray")

> persp(x, y, z, theta = 135, phi = 30, col = fill, 
    scale = FALSE, ltheta = -120, lphi = 15, shade = 0.65, axes = FALSE)

> persp(x, y, z, theta = 135, phi = 30, col = "green3", 
    scale = FALSE, ltheta = -120, shade = 0.75, border = NA, 
    box = FALSE)

> fcol <- fill

> fcol[] <- terrain.colors(nrow(fcol))

> persp(x, y, z, theta = 135, phi = 30, col = fcol, 
    scale = FALSE, ltheta = -120, shade = 0.3, border = NA, box = FALSE)

> fcol <- fill

> zi <- volcano[-1, -1] + volcano[-1, -61] + volcano[-87, 
    -1] + volcano[-87, -61]

> fcol[-i1, -i2] <- terrain.colors(20)[cut(zi, quantile(zi, 
    seq(0, 1, len = 21)), include.lowest = TRUE)]

> persp(x, y, 2 * z, theta = 110, phi = 40, col = fcol, 
    scale = FALSE, ltheta = -120, shade = 0.4, border = NA, box = FALSE)

> par(op)


	demo(recursion)
	---- ~~~~~~~~~

> area <- function(f, a, b, ..., fa = f(a, ...), fb = f(b, 
    ...), limit = 10, eps = 1e-05) {
    h <- b - a
    d <- (a + b)/2
    fd <- f(d, ...)
    a1 <- ((fa + fb) * h)/2
    a2 <- ((fa + 4 * fd + fb) * h)/6
    if (abs(a1 - a2) < eps) 
        .... [TRUNCATED] 

> fbeta <- function(x, alpha, beta) {
    x^(alpha - 1) * (1 - x)^(beta - 1)
}

> b0 <- area(fbeta, 0, 1, alpha = 3.5, beta = 1.5)

> b1 <- exp(lgamma(3.5) + lgamma(1.5) - lgamma(5))

> c(b0, b1, b0 - b1)
[1]  1.227170e-01  1.227185e-01 -1.443996e-06

> fbeta.tmp <- function(x, alpha, beta) {
    val <<- c(val, x)
    x^(alpha - 1) * (1 - x)^(beta - 1)
}

> val <- NULL

> b0 <- area(fbeta.tmp, 0, 1, alpha = 3.5, beta = 1.5)

> plot(val, fbeta(val, 3.5, 1.5), pch = 0)

> area <- function(f, a, b, ..., limit = 10, eps = 1e-05) {
    area2 <- function(f, a, b, ..., fa = f(a, ...), fb = f(b, 
        ...), limit = limit, eps = eps) {
        h <- b - a
        d <- (a + b)/2
        fd <- f(d, ...)
        a1 <- ((fa +  .... [TRUNCATED] 


	demo(scoping)
	---- ~~~~~~~

> open.account <- function(total) {
    list(deposit = function(amount) {
        if (amount <= 0) stop("Deposits must be positive!\n")
        total <<- total + amount
        cat(amount, "deposited. Your balance is", total, "\n\n")
    }, withdraw =  .... [TRUNCATED] 

> ross <- open.account(100)

> robert <- open.account(200)

> ross$withdraw(30)
30 withdrawn.  Your balance is 70 


> ross$balance()
Your balance is 70 


> robert$balance()
Your balance is 200 


> ross$deposit(50)
50 deposited. Your balance is 120 


> ross$balance()
Your balance is 120 


> try(ross$withdraw(500))
Error in ross$withdraw(500) : You don't have that much money!
In addition: Warning messages: 
1: is.nan() applied to non-(list or vector) in: fn(obj) 
2: is.nan() applied to non-(list or vector) in: fn(obj) 
3: is.na() applied to non-(list or vector) in: fn(obj) 
4: is.nan() applied to non-(list or vector) in: fn(obj) 
5: is.nan() applied to non-(list or vector) in: fn(obj) 
6: is.nan() applied to non-(list or vector) in: fn(obj) 


	demo(smooth)
	---- ~~~~~~

> op <- par(ask = interactive(), mfrow = c(1, 1))

> example(smooth)

smooth> x1 <- c(4, 1, 3, 6, 6, 4, 1, 6, 2, 4, 2)

smooth> (x3R <- smooth(x1, "3R"))
3R Tukey smoother resulting from  smooth(x = x1, kind = "3R") 
 used 2 iterations
 [1] 3 3 3 6 6 4 4 4 2 2 2

smooth> smooth(x3R, kind = "S")
S Tukey smoother resulting from  smooth(x = x3R, kind = "S") 
 changed
 [1] 3 3 3 3 4 4 4 4 2 2 2

smooth> sm.3RS <- function(x, ...) smooth(smooth(x, "3R", 
    ...), "S", ...)

smooth> y <- c(1, 1, 19:1)

smooth> plot(y, main = "misbehaviour of \"3RSR\"", col.main = 3)

smooth> lines(sm.3RS(y))

smooth> lines(smooth(y))

smooth> lines(smooth(y, "3RSR"), col = 3, lwd = 2)

smooth> x <- c(8:10, 10, 0, 0, 9, 9)

smooth> plot(x, main = "breakdown of  3R  and  S  and hence  3RSS")

smooth> matlines(cbind(smooth(x, "3R"), smooth(x, "S"), smooth(x, 
    "3RSS"), smooth(x)))

smooth> data(presidents)

smooth> presidents[is.na(presidents)] <- 0

smooth> summary(sm3 <- smooth(presidents, "3R"))
3R Tukey smoother resulting from
 smooth(x = presidents, kind = "3R") ;  n = 120 
 used 4 iterations
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
    0.0    44.0    57.0    54.2    71.0    82.0 

smooth> summary(sm2 <- smooth(presidents, "3RSS"))
3RSS Tukey smoother resulting from
 smooth(x = presidents, kind = "3RSS") ;  n = 120 
 used 5 iterations
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
   0.00   44.00   57.00   55.45   69.00   82.00 

smooth> summary(sm <- smooth(presidents))
3RS3R Tukey smoother resulting from
 smooth(x = presidents) ;  n = 120 
 used 7 iterations
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
  24.00   44.00   57.00   55.88   69.00   82.00 

smooth> all.equal(c(sm2), c(smooth(smooth(sm3, "S"), "S")))
[1] TRUE

smooth> all.equal(c(sm), c(smooth(smooth(sm3, "S"), "3R")))
[1] TRUE

smooth> plot(presidents, main = "smooth(presidents0, *) :  3R and default 3RS3R")

smooth> lines(sm3, col = 3, lwd = 1.5)

smooth> lines(sm, col = 2, lwd = 1.25)

> showSmooth <- function(x, leg.x = 1, leg.y = max(x)) {
    ss <- cbind(x, "3c" = smooth(x, "3", end = "copy"), "3" = smooth(x, 
        "3"), "3Rc" = smooth(x, "3R", end = "copy"), "3R" = smooth(x, 
        "3R"), sm = smooth(x))
    k <- ncol(ss) -  .... [TRUNCATED] 

> for (x in list(c(4, 6, 2, 2, 6, 3, 6, 6, 5, 2), c(3, 
    2, 1, 4, 5, 1, 3, 2, 4, 5, 2), c(2, 4, 2, 6, 1, 1, 2, 6, 
    3, 1, 6), x1, )) print(t(showSmooth(x)))
    [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10]
x      4    6    2    2    6    3    6    6    5     2
3c     4    4    2    2    3    6    6    6    5     2
3      4    4    2    2    3    6    6    6    5     3
3Rc    4    4    2    2    3    6    6    6    5     2
3R     4    4    2    2    3    6    6    6    5     3
sm     4    4    4    3    3    6    6    6    5     3
    [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11]
x      3    2    1    4    5    1    3    2    4     5     2
3c     3    2    2    4    4    3    2    3    4     4     2
3      2    2    2    4    4    3    2    3    4     4     4
3Rc    3    2    2    4    4    3    3    3    4     4     2
3R     2    2    2    4    4    3    3    3    4     4     4
sm     2    2    2    2    3    3    3    3    4     4     4
    [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11]
x      2    4    2    6    1    1    2    6    3     1     6
3c     2    2    4    2    1    1    2    3    3     3     6
3      2    2    4    2    1    1    2    3    3     3     3
3Rc    2    2    2    2    1    1    2    3    3     3     6
3R     2    2    2    2    1    1    2    3    3     3     3
sm     2    2    2    2    2    2    2    3    3     3     3
    [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11]
x      4    1    3    6    6    4    1    6    2     4     2
3c     4    3    3    6    6    4    4    2    4     2     2
3      3    3    3    6    6    4    4    2    4     2     2
3Rc    4    3    3    6    6    4    4    4    2     2     2
3R     3    3    3    6    6    4    4    4    2     2     2
sm     3    3    3    3    4    4    4    4    2     2     2

> par(op)
> 
> cat("Time elapsed: ", proc.time() - .ptime, "\n")
Time elapsed:  10.81 0.36 12.77 NA NA 
> 
