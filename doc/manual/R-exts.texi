\input texinfo
@c %**start of header
@setfilename R-exts.info
@settitle Writing R Extensions
@setchapternewpage on
@c %**end of header

@syncodeindex fn vr

@dircategory Programming
@direntry
* R Extensions: (R-exts).      Writing R Extensions.
@end direntry

@finalout

@include R-defs.texi
@include version.texi

@ifinfo
This is a guide to extending R.

Copyright 1999 R Development Core Team

Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

@ignore
Permission is granted to process this file through TeX and print the
results, provided the printed document carries a copying permission
notice identical to this one except for the removal of this paragraph
(this paragraph not being relevant to the printed manual).

@end ignore
Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided that the
entire resulting derived work is distributed under the terms of a
permission notice identical to this one.

Permission is granted to copy and distribute translations of this manual
into another language, under the above conditions for modified versions,
except that this permission notice may be stated in a translation
approved by the Free Software Foundation.
@end ifinfo

@titlepage
@title Writing R Extensions
@subtitle Version @value{VERSION}
@author R Development Core Team
@page
@vskip 0pt plus 1filll
Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided that the
entire resulting derived work is distributed under the terms of a
permission notice identical to this one.

Permission is granted to copy and distribute translations of this manual
into another language, under the above conditions for modified versions,
except that this permission notice may be stated in a translation
approved by the Free Software Foundation.

Copyright @copyright{} 1999 R Development Core Team
@end titlepage

@contents

@node Top, Legalese, (dir), (dir)

@menu
* Legalese::                    
* Creating R packages::         
* Writing R documentation::     
* System and foreign language interfaces::  
* R (internal) programming miscellania::  
* Function and variable index::  
* Concept index::               
@end menu

@node Legalese, Creating R packages, Top, Top
@unnumbered Legalese

@menu
* Acknowledgments::             
@end menu

This document is @copyright{} 1999 by the R Development Core Team.

This document is free software; you can redistribute it and/or modify it
under the terms of the GNU General Public License as published by the
Free Software Foundation; either version 2, or (at your option) any
later version.

This document is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
General Public License for more details.

A copy of the GNU General Public License is available via WWW at

@display
@uref{http://www.gnu.org/copyleft/gpl.html}.
@end display

@noindent
You can also obtain it by writing to the Free Software Foundation, Inc.,
675 Mass Ave, Cambridge, MA 02139, USA.

@node Acknowledgments,  , Legalese, Legalese
@section Acknowledgments

The contributions of Saikat DebRoy (who wrote the first draft of a guide
to using @code{.Call} and @code{.External}) are gratefully acknowledged.

@node Creating R packages, Writing R documentation, Legalese, Top
@chapter Creating R packages

Packages provide a mechanism for loading optional code and attached
documentation as needed.  The @R{} distribution provides several
packages, such as @strong{eda}, @strong{mva}, and @strong{stepfun}.

A package consists of a subdirectory containing the files
@file{DESCRIPTION}, @file{INDEX}, and @file{TITLE}, and the
subdirectories @file{R}, @file{data}, @file{exec}, @file{inst},
@file{man}, and @file{src} (some of which can be missing).

@c FIXME Add something about configure and cleanup.

The @file{DESCRIPTION} file contains basic information about the package
in the following format:

@smallexample
Package: e1071
Version: 0.7-3
Author: Compiled by Fritz Leisch <Friedrich.Leisch@@ci.tuwien.ac.at>.
Description: Miscellaneous functions used at the Department of
        Statistics at TU Wien (E1071). 
Depends:
License: GPL version 2 or later
@end smallexample

@noindent
Continuation lines (e.g., for descriptions longer than one line) start
with a whitespace character.  The license field should contain an
explicit statement or a well-known abbreviation (such as @samp{GPL},
@samp{LGPL}, @samp{BSD}, or @samp{Artistic}), perhaps followed by a
reference to the actual license file.  It is very important that you
include this information!  Otherwise, it may not even be legally correct
for others to distribute copies of the package.

The @file{TITLE} file contains a line giving the name of the package and
a brief description.  @file{INDEX} contains a line for each sufficiently
interesting object in the package, giving its name and a description
(functions such as print methods not usually called explicitly might not
be included).  Note that you can automatically create this file using
something like @code{R CMD Rdindex man/*.Rd > INDEX}, provided that Perl
is available on your system.

The @file{R} subdirectory contains @R{} code files.  The code files to
be installed must start with a (lower- or uppercase) letter and have one
of the extensions @file{.R}, @file{.S}, @file{.q}, @file{.r}, or
@file{.s}.  We recommend using @file{.R}, as this extension seems to be
not used by any other software.  It should be possible to read in the
files using @code{source()}, so R objects must be created by
assignments.  Note that there need be no connection between the name
of the file and the R objects created by it.  If necessary, one of these
files (historically @file{zzz.R}) should use @code{library.dynam()}
@emph{inside} @code{.First.lib()} to load compiled code.

The @file{man} subdirectory should contain @R{} documentation files for
the objects in the package.  The documentation files to be installed
must also start with a (lower- or uppercase) letter and have the
extension @file{.Rd} (the default) or @file{.rd}.

The @file{R} and @file{man} subdirectories may contain OS-specific
subdirectories named @code{unix}, @code{windows} or @code{mac}.

The C or FORTRAN source and optionally a @file{Makefile} for the compiled
code is in @file{src}.  Note that the @file{Makefile} most likely is not
needed, and if one is to be distributed considerable care is needed to
make it general enough to work on all @R{} platforms.

The @file{data} subdirectory is for additional data files the package
makes available for loading using @code{data()}.  Currently, data files
can have one of three types as indicated by their extension: plain R
code (@file{.R} or @file{.r}), tables (@file{.tab}, @file{.txt}, or
@file{.csv}), or @code{save()} images (@file{.RData} or @file{.rda}).
The subdirectory should contain a @file{00Index} file that describes the
datasets available.

The contents of the @file{inst} subdirectory will be copied recursively
to the installation directory.

Finally, @file{exec} could contain additional executables the package
needs, typically shell or Perl scripts.  This mechanism is currently not
used by any Unix package, and still experimental.

@menu
* Package bundles::             
@end menu

@node  Package bundles,  , Creating R packages, Creating R packages
@section Package bundles

Sometimes it is convenient to distribute several packages as a
@emph{bundle}. (The main current example is @code{VR} which contains
four packages.)  The installation scripts on both Unix and Windows can
handle package bundles as from @R{} 0.90.1.

The @file{DESCRIPTION} file of a bundle has an extra @code{Bundle:}
field, as in

@smallexample
Bundle: VR
Contains: MASS class nnet spatial
Version: 6.1-6 (1999/11/26)
Author: S original by Venables & Ripley.
  R port by Brian Ripley <ripley@@stats.ox.ac.uk>, following earlier
  work by Kurt Hornik and Albrecht Gebhardt.
BundleDescription: Various functions from the libraries of Venables and
  Ripley, `Modern Applied Statistics with S-PLUS' (3rd edition).
License: GPL (version 2 or later)
@end smallexample

The @code{Contains:} field lists the packages, which should be contained
in separate subdirectories with the names given.  These are standard
packages in all respects except that the @file{DESCRIPTION} file is
replaced by a @file{DESCRIPTION.in} file which just contains fields
additional to the @file{DESCRIPTION} file of the bundle, for example

@smallexample
Package: spatial
Description: Functions for kriging and point pattern analysis.
@end smallexample

@node Writing R documentation, System and foreign language interfaces, Creating R packages, Top
@chapter Writing R documentation

@menu
* The documentation source tree::  
* Documentation format::        
* Sectioning::                  
* Marking text::                
* Mathematics::                 
* Miscellaneous::               
* Platform-specific sections::  
@end menu

@node The documentation source tree, Documentation format, Writing R documentation, Writing R documentation
@section The documentation source tree

The help files containing detailed documentation for (potentially) all
@R{} objects are in the @file{src/library/*/man} subdirectories of the
@R{} source tree, where @samp{*} stands for @strong{base} where all the
standard objects are, and for ``standard'' packages such as @strong{eda}
and @strong{mva}.  The @file{doc/manual} subdirectory contains code for
running the translated help files through La@TeX{} and further documents
pertaining to @R{}.

@node Documentation format, Sectioning, The documentation source tree, Writing R documentation
@section Documentation format

The help files are written in a form and syntax---closely resembling
@TeX{} and La@TeX{}---which can be processed into a variety of formats,
including La@TeX{}, [TN]roff, and @HTML{}.  The translation is carried
out by the @sc{Perl} script @file{Rdconv} in @file{$R_HOME/bin}.

For a given @R{} function @code{myfun}, use the @R{} command
@code{prompt(myfun)} to produce the file @file{myfun.Rd}, a ``raw''
documentation file that can now be filled in with information.  The
basic layout of such a file is as follows.

@table @code
@item \name@{myfun@}
@findex \name
@var{myfun} is the basename of the file.

@item \alias@{myfun@}
@itemx \alias@{@var{more_aliases_1}@}
@itemx \alias@{@var{more_aliases_2}@}
@findex \alias
etc.  Need one @code{\alias@{@}} for each topic explained in the help
file.
@quotation
@strong{Note:} Each file should contain at least the
@code{\alias@{@var{name}@}} line.
@end quotation


@item \title@{@var{Title}@}
@findex \title

@item \description@{@dots{}@}
@findex \description
A short description of what the function(s) do(es) (one paragraph, a few
lines only).

@item \usage@{myfun(@var{arg1}, @var{arg2}, @dots{})@}
@findex \usage
One or more lines showing the synopsis of the function(s) and variables
documented in the file.  These are set verbatim in typewriter font.

@item \arguments@{@dots{}@}
@findex \arguments
Description of the function's arguments, in the following form:

@display
@var{Some optional text @emph{before} the optional list.} 
@code{\item@{@var{arg1}@}@{@var{Description of arg1.}@}}
@code{\item@{@var{arg2}@}@{@var{Description of arg2.}@}}
@r{  etc.} 
@var{Some optional text @emph{after} the list.}
@end display


@item \details@{@dots{}@}
@findex \details
A detailed if possible precise description of the functionality
provided.  Sometimes, precise @code{\references@{@}} can be given
instead.

@item \value@{@dots{}@}
@findex \value
Description of the function's return value.  If a list with multiple
values is returned, you can use

@display
@code{\item@{comp1@}@{@var{Description of result component `comp1'}@}}
@code{\item@{comp2@}@{@var{Description of result component `comp2'}@}}
@end display
etc.

@item \references@{@dots{}@}
@findex \references
Section of references to the literature; use @code{\url@{@}} for web
pointers.  Optional as well as all the following sections.

@item \section@{@var{name}@}@{@var{text}@}
and maybe more @code{\section@{@}} environments.

@item \note@{@var{Some note you want to have pointed out.}@}
@findex \note

@item \author@{@dots{}@}
@findex \author
Who you are.  Use @code{\email@{@}} without extra delimiters (@samp{( )}
or @samp{< >}) or @code{\url@{@}}.

@item \seealso@{@dots{}@}
@findex \seealso
Pointers to related @R{} objects, using @code{\link@{@}}, usually as
@code{\code@{\link@{@}@}}.

@findex \examples
@findex \testonly
@findex \dontrun
@item \examples@{@dots{}@}
Examples of how to use the function.  These are set verbatim in
typewriter font.

@quotation
@strong{Note:} Use examples which are @emph{directly} executable!  Use
random number generators (e.g., @code{x <- rnorm(100)}), or a standard
data set loadable via @code{data(@dots{})} (see @code{data()} for info) to
define data!
@end quotation

By default, text inside @code{\examples@{@}} will be displayed in the
output of the help page and run by @kbd{make check}.  You can use
@code{\dontrun@{@}} for commands that should only be shown, but not run,
and @code{\testonly@{@}} for extra commands for testing @R{} that should
not be shown to users.

For example,
@example
x <- runif(10)       @r{Shown and run.}
\dontrun@{plot(x)@}    @r{Only shown.}
\testonly@{log(x@}     @r{Only run.}
@end example

@item \keyword@{@var{key_1}@}
@itemx \keyword@{@var{key_2}@}
@findex \keyword
Use at least one keyword from the list in @file{$R_HOME/doc/KEYWORDS}.

@end table

@node Sectioning, Marking text, Documentation format, Writing R documentation
@section Sectioning

To begin a new paragraph or leave a blank in an example, just insert an
empty line (as in (La)@TeX{}).  To break a line, use @code{\cr}.

In addition to the predefined sections (such as @code{\description@{@}},
@code{\value@{@}}, etc.), you can ``define'' arbitrary ones by
@code{\section@{@var{section_title}@}@{@dots{}@}}.
@findex \section
E.g.,

@display
@code{\section@{Warning@}@{You must not call this function unless @dots{}@}}
@end display

@noindent Note that the additonal named sections are always inserted at
fixed positions in the output (before @code{\note}, @code{\seealso} and
the examples), no matter where they appear in the input.

@node Marking text, Mathematics, Sectioning, Writing R documentation
@section Marking text

The following logical markup commands are available for indicating
specific kinds of text.

@quotation
@multitable @columnfractions .20 .70
@item @code{\bold@{@var{word}@}}
@findex \bold
@tab set @var{word} in @strong{bold} font if possible
@item @code{\emph@{@var{word}@}}
@findex \emph
@tab emphasize @var{word} using @emph{italic} font if possible
@item @code{\code@{@var{word}@}}
@findex \code
@tab for pieces of code, using @code{typewriter} font if possible
@item @code{\file@{@var{word}@}}
@findex \file
@tab for file names
@item @code{\email@{@var{word}@}}
@findex \email
@tab for email addresses
@item @code{\url@{@var{word}@}}
@findex \url
@tab for URLs
@end multitable
@end quotation

@noindent The first two, @code{\bold} and @code{\emph}, should be used
in plain text for emphasis.

Fragments of @R{} code, including the names of @R{} objects, should be
marked using @code{\code}.  Only backslashes and percent signs need to be
escaped (by a backslash) inside @code{\code}.

Finally, @code{\link@{@var{foo}@}} (usually in the combination
@code{\code@{\link@{@var{foo}@}@}}) produces a hyperlink to the help
page for object @var{foo}.  One main usage of @code{\link} is in the
@code{\seealso} section of the help page, @pxref{Documentation format},
above.  (This only affects the creation of hyperlinks, for example in
the @HTML{} pages used by @code{help.start()}.)

@node Mathematics, Miscellaneous, Marking text, Writing R documentation
@section Mathematics

Mathematical formula are something we want ``perfectly'' for printed
documentation (i.e., for the conversion to La@TeX{} and PostScript
subsequently) and still want something useful for ASCII and @HTML{}
online help.

@findex \eqn
@findex \deqn
To this end, the two commands @code{\eqn@{@var{latex}@}@{@var{ascii}@}}
and @code{\deqn@{@var{latex}@}@{@var{ascii}@}} are used.  Where
@code{\eqn} is used for ``inline'' formula (corresponding to
(La)@TeX{}'s @code{$@dots{}$}, @code{\deqn} gives ``displayed
equations'' (a la La@TeX{}'s @code{displaymath} environment, or @TeX{}'s
@code{$$@dots{}$$}).

Both commands can also be used as @code{\eqn@{@var{latexascii}@}} (only
@emph{one} argument) which then is used for both @var{latex} and
@var{ascii}.

The following example is from the @code{Poisson} help page:

@example
\deqn@{p(x) = @{\lambda^x\ \frac@{e^@{-\lambda@}@}@{x!@}@}
     @{p(x) = lambda^x exp(-lambda)/x!@}
for \eqn@{x = 0, 1, 2, ...@}.
@end example

@iftex
For the La@TeX{} manual, this becomes
@display
@tex
$$ p(x) = \lambda^x\ {e^{-\lambda} \over x!} $$
for $x = 0, 1, 2, \ldots$.
@end tex
@end display
@end iftex

For the @HTML{} and the ``direct'' (man-like) on-line help we get

@example
    p(x) = lambda^x exp(-lambda)/x!

for x = 0, 1, 2, ....
@end example

For historic reasons mostly, the @TeX{}/La@TeX{} commands @code{\alpha},
@code{\Alpha}, @code{\beta}, @code{\Gamma}, @code{\epsilon},
@code{\lambda}, @code{\mu}, @code{\pi}, @code{\sigma}, @code{\left(} and
@code{\right)} exist.  These can be used directly, without using the
@code{\eqn} diversion.
@findex \alpha
@findex \Alpha
@findex \beta
@findex \Gamma
@findex \epsilon
@findex \lambda
@findex \mu
@findex \pi
@findex \sigma
@findex \left(
@findex \right)

@node Miscellaneous, Platform-specific sections, Mathematics, Writing R documentation
@section Miscellaneous

@findex \R
Use @code{\R} for the @R{} system itself (you don't need extra
@samp{@{@}} or @samp{\}).  Use @code{\dots} for the dots in function
argument lists @samp{@dots{}}, and @code{\ldots} for ellipsis dots.

After a @samp{%}, you can put your own comments regarding the help
text.  This will be completely disregarded, normally.  Therefore, you can
also use it to make part of the ``help'' invisible.

@noindent @strong{Escaping Special Characters.}  You can produce a
backslash (@samp{\} by escaping it by another backslash.  (Note that
@code{\cr} is used for generating line breaks.)

The ``comment'' and ``control'' characters @samp{%} and @samp{\}
@emph{always} need to be escaped.  Inside the verbatim-like commands
(@code{\code} and @code{\examples}), no other characters are special.

In ``regular'' text (no verbatim, no @code{\eqn}, @dots{}), you
currently must escape all La@TeX{} special characters, i.e., besides
@samp{%}, @samp{@{}, and @samp{@}}, the four specials @samp{$},
@samp{&}, @samp{#}, and @samp{_} are produced by preceding each with a
@samp{\}.  Further, enter @samp{^} as @code{\eqn@{\hat@{@}@}@{^@}}, and
@samp{~} by @code{\eqn@{\tilde@{@}@}@{~@}}.  Also, @samp{<}, @samp{>},
and @samp{|} must only be used in math mode, i.e., within @code{\eqn} or
@code{\deqn}.

@node  Platform-specific sections,  , Miscellaneous, Writing R documentation
@section Platform-specific documentation

Sometimes the documentation needs to differ by platform.  Currently
three OS-specific options are available, @code{unix}, @code{windows} and
@code{mac}, and lines in the help source file can be enclosed in

@smallexample
#ifdef OS
   ...
#endif
@end smallexample

@noindent
or

@smallexample
#ifndef OS
   ...
#endif
@end smallexample

@noindent
for OS-specific inclusion or exclusion.

If the differences between platforms are extensive or the @R{} objects
documented are only relevant to one platform, platform-specific
@code{.Rd} files can be put in a  @file{unix}, @file{windows} or
@file{mac} subdirectory.


@node System and foreign language interfaces, R (internal) programming miscellania, Writing R documentation, Top
@chapter System and foreign language interfaces

@menu
* Operating system access::     
* Interface functions .C and .Fortran::  
* dyn.load and dyn.unload::     
* Handling R objects in C::     
* Interface Functions .Call and .External::  
* Evaluating R Expressions from C::  
@end menu

@node  Operating system access, Interface functions .C and .Fortran, System and foreign language interfaces, System and foreign language interfaces
@section  Operating system access

Access to operating system functions is via the @R{} function
@code{system}.  The details will differ by platform (see the on-line
help), and about all that can safely be assumed is that the first
argument will be a string @code{command} that will be passed for
execution (not necessarily by a shell) and the second argument will be
@code{internal} which if true will collect the output of the command
into an @R{} character vector.

The function @code{system.time} is available for timing (although the
information available may be limited on non-Unix-like platforms).

@node Interface functions .C and .Fortran, dyn.load and dyn.unload, Operating system access, System and foreign language interfaces
@section Interface functions @code{.C} and @code{.Fortran}

@findex .C
@findex .Fortran

These two functions provide a standard interface to compiled code that
has been linked into @R{}, either at build time or via @code{dyn.load}
(q.v.).  They are primarily intended for compiled C and Fortran code
respectively, but the @code{.C} function can be used with other
languages which can generate C interfaces, for example C++.

The first argument to each function is a character string given the
symbol name as known to C or Fortran, that is the function or subroutine
name.  (The mapping to the symbol name in the load table is given by the
functions @code{symbol.C} and @code{symbol.For}; that the symbol is
loaded can be tested by, for example,
@code{is.loaded(symbol.C("loglin"))}.)

There can be up to 65 further arguments giving @R{} objects to be passed
to compiled code.  Normally these are copied before being passed in, and
copied again to an @R{} list object when the compiled code returns.  If
the arguments are given names, these are used as names for the
components in the returned list object (but not passed to the compiled code).

The following table gives the mapping between the modes of @R{} vectors
and the types of arguments to a C function or Fortran subroutine.

@quotation
@multitable {storage.mode} {RRR storage.mode} {RRR storage.mode} {DOUBLE PRECISION}
@item @tab @R{} storage mode @tab  C type  @tab   Fortran type
@item @tab @code{logical}   @tab @code{int *}     @tab @code{INTEGER}
@item @tab @code{integer}   @tab @code{int *}     @tab @code{INTEGER}
@item @tab @code{double}    @tab @code{double *}  @tab @code{DOUBLE PRECISION}
@item @tab @code{complex}   @tab @code{Rcomplex *} @tab @code{DOUBLE COMPLEX}
@item @tab @code{character} @tab @code{char **}   @tab @code{CHARACTER*255}
@end multitable
@end quotation

C type @code{Rcomplex} is a structure with @code{double} members
@code{r} and @code{i} defined in the header file @file{Complex.h}.  Only
a single character string can be passed to or from Fortran, and the
success of this is compiler-dependent.  Other @R{} objects can be passed
to @code{.C}, but it is better to use one of the other interfaces.  An
exception is passing an @R{} function for use with @code{call_R}, when
the object can be handled as @code{void *} en route to @code{call_R},
but even there @code{.Call} is to be preferred.

It is possible to pass numeric vectors of storage mode @code{double} to
C as @code{float *} or Fortran as @code{REAL} by setting the attribute
@code{Csingle}, most conveniently by using the @R{} functions
@code{as.single}, @code{single} or @code{storage.mode}.  This is
intended only to be used to aid interfacing to existing C or Fortran
code.

Unless formal argument @code{NAOK} is true, all the other arguments are
checked for missing values @code{NA} and for the IEEE special values
@code{NaN}, @code{Inf} and @code{-Inf}, and the presence of any of these
generates an error.  If it is true, these values are passed unchecked.

Argument @code{DUP} can be used to suppress copying.  It is dangerous:
see the on-line help for arguments against its use.  It is not possible
to pass numeric vectors as @code{float *} or @code{REAL} if @code{DUP=TRUE}.

Finally, argument @code{PACKAGE} confines the search for the symbol name
to a specific shared library (or use @code{"base"} for code compiled
into @R{}).  Its use is highly desirable, as there is no way to avoid
two package writers using the same symbol name, and such name clashes
are normally sufficient to cause @R{} to crash.

Note that the compiled code should not return anything except through
its arguments: C functions should be of type @code{void} and Fortran
subprograms should be subroutines.

To fix ideas, let us consider a very simple example which convolves two
finite sequences. (This is hard to do fast in interpreted @R{} code, but
easy in C code.)  We could do this using @code{.C} by

@example
void convolve(double *a, int *na, double *b, int *nb, double *ab)
@{
  int i, j, nab = *na + *nb - 1;

  for(i = 0; i < nab; i++) ab[i] = 0.0;
  for(i = 0; i < *na; i++)
    for(j = 0; j < *nb; j++) ab[i + j] += a[i] * b[j];
@}
@end example

@noindent
called from @R{} by

@example
conv <- function(a, b)
  .C("convolve", as.double(a), as.integer(length(a)),
     as.double(b), as.integer(length(b)),
     ab = double(length(a) + length(b) - 1))$ab
@end example

Note that we take care to coerce all the arguments to the correct @R{}
storage mode before calling @code{.C}; mistakes in matching the types
can lead to wrong results or hard-to-catch errors.


@node dyn.load and dyn.unload, Handling R objects in C, Interface functions .C and .Fortran, System and foreign language interfaces
@section @code{dyn.load} and @code{dyn.unload}

@findex dyn.load
@findex dyn.unload

Compiled code to be used with @R{} is loaded as a shared library (Unix)
or DLL (Windows).  The library/DLL is loaded by @code{dyn.load} and
unloaded by @code{dyn.unload}.  Unloading is not normally necessary, but
it is needed to allow the DLL to be re-built on some platforms,
including Windows.

The first argument to both functions is a character string giving the
path to library.  Programmers should not assume a specific file
extension for the library (such as @code{.so}) but use a construction
like

@example
file.path(path1, path2, paste("mylib", .Platform$dynlib.ext, sep=""))
@end example

@noindent
for platform independence.  On Unix systems the path supplied to
@code{dyn.load} can be an absolute path, one relative to the current
directory or, if it starts with @code{~}, relative to the user's home
directory.

Loading is most often done via a call to @code{library.dynam} in the
@code{.First.lib} function of a package. This has the form

@smallexample
library.dynam("libname", package, lib.loc)
@end smallexample
@noindent
where @code{libname} is the library/DLL name with the extension omitted.

Under some Unix systems there is a choice of how the symbols are
resolved when the library is loaded, governed by the arguments
@code{local} and @code{now}.  Only use these if really necessary: in
particular using @code{now=FALSE} and then calling an unresolved symbol
will terminate @R{} unceremoniously.

If a library/DLL is loaded more than once the most recent version is
used.  More generally, if the same symbol name appears in several
libraries, the most recently loaded occurrence is used. The
@code{PACKAGES} argument provides a good way to avoid any ambiguity in
which occurrence is meant.

@section Interfacing C++ code

@noindent
(Contributed by @emph{Adrian Trapletti}.)

Suppose we have the following hypothetical C++ library, consisting of
the two files @file{X.hh} and @file{X.cc}, which we want to use in R:

@smallexample
@cartouche
// X.hh

class X
@{
public:
  X ();
  ~X ();
@};

class Y
@{
public:
  Y ();
  ~Y ();
@};
@end cartouche
@end smallexample

@smallexample
@cartouche
// X.cc

#include <iostream.h>
#include "X.hh"

static Y y;

X::X()  @{ cout << "constructor X" << endl; @}
X::~X() @{ cout << "destructor X" << endl; @}
Y::Y()  @{ cout << "constructor Y" << endl; @}
Y::~Y() @{ cout << "destructor Y" << endl; @}
@end cartouche
@end smallexample

@noindent implementing the 2 classes @code{X} and @code{Y}.  The only
thing we have to do is writing a wrapper function and ensuring that the
function is enclosed in

@smallexample
extern "C" @{

@}
@end smallexample

For example,

@smallexample
@cartouche
// X_main.cc:

#include "X.hh"

extern "C" @{

void X_main ()
@{
  X x;
@}

@}
@end cartouche
@end smallexample

Compiling and linking should be done with the C++ compiler-linker.  For
example, under Linux we might use

@smallexample
g++ -c X.cc
g++ -c X_main.cc
g++ -shared -o X.so X_main.o X.o
@end smallexample

Otherwise (i.e., linking, e.g., with GNU ld) the C++ initialization code
(and hence the constructor of the static variable @code{Y}) are not
called.

Now starting R yields

@smallexample
R: Copyright 1999, The R Development Core Team
Version 0.63.2  (January 12, 1999)
...
Type    "q()" to quit R.

R> dyn.load("X.so")
constructor Y
R> .C("X_main")
constructor X
destructor X
R> q()
Save workspace image? [y/n/c]: y
destructor Y
@end smallexample

@node Handling R objects in C, Interface Functions .Call and .External, dyn.load and dyn.unload, System and foreign language interfaces
@section Handling R objects in C

Using C code to speed up the execution of an @R{} function is often very
fruitful.  Traditionally this has been done via the @code{.C} function
in @R{}.
@c (for details, see the @R{} documentation on @code{.C}).
One restriction of this interface is that the @R{} objects can not be
handled directly in C.  This becomes more troublesome when one wishes to
call @R{} functions from within the C code.  There is a C function
provided called @code{call_R} (also known as @code{call_S} for
compatibility with S) that can do that, but it is cumbersome to use, and
the mechanisms documented here are usually simpler to use, as well as
more powerful.

If a user really wants to write C code using internal @R{} data
structures, then that can be done using the @code{.Call} and
@code{.External} function.  The syntax for the calling function in @R{}
in each case is similar to that of @code{.C}, but the two functions have
rather different C interfaces.  Generally the @code{.Call} interface
(which is modelled on the interface of the same name in S version 4) is
a little simpler to use, but @code{.External} is a little more general.

A call to @code{.Call} is very similar to @code{.C}, for example

@example
.Call("convolve2", a, b)
@end example

@noindent
The first argument should be a character string giving a C symbol name
of code that has already been loaded into @R{}.  Up to 65 @R{} objects
can passed as arguments.  The C side of the interface is

@example
#include <S.h>

SEXP convolve2(SEXP a, SEXP b)
 ...
@end example

A call to @code{.External} is almost identical

@example
.External("convolveE", a, b)
@end example

@noindent
but the C side of the interface is different, having only one argument

@example
#include <Rinternals.h>

SEXP convolveE(SEXP args)
 ...
@end example

@noindent
Here @code{args} is a @code{LISTSXP}, a Lisp-style list from which the
arguments can be extracted.

In each case the @R{} objects are available for manipulation via a set
of functions and macros defined in the header file @file{Rinternals.h}
or some higher-level macros defined in @file{Rdefines.h} (included by
@code{S.h}).  Details on @code{.Call} and @code{.External} are given
further below.

Before you decide to use @code{.Call} or @code{.External}, you should
look at other alternatives.  First, consider working in interpreted @R{}
code; if this is fast enough, this is normally the best option.  You
should also see if using @code{.C} is enough.  If the task to be
performed in C is simple enough requiring no call to @R{}, @code{.C}
suffices.  The new interfaces are recent additions to S and @R{}, and a
great deal of useful code has been written using just @code{.C} before
they were available.  The @code{.Call} and @code{.External} interfaces
allow much more control, but they also impose much greater
responsibilities so need to be used with care.

There are two approaches that can be taken to handling @R{} objects from
within C code.  The first (historically) is to use the macros and
functions that have been used to implement the core parts of @R{}
through @code{.Internal} calls.  A public subset of these is defined in
the header file @file{Rinternals.h} in the directory
@file{$R_HOME/include} that should be available on any @R{}
installation.

A more recent approach is to use @R{} versions of the macros and
functions defined for the S version 4 interface @code{.Call}, which are
defined in the header file @file{Rdefines.h}, included by @file{S.h}.
This is a somewhat simpler approach, and is certainly to be preferred if
the code might be shared with S at any stage.

A substantial amount of @R{} is implemented using the functions and
macros described here, so the @R{} source code provides a rich source of
examples and ``how to do it':' indeed many of the examples here were
developed by examining closely @R{} system functions for similar tasks.
Do make use of the source code for inspirational examples.

It is necessary to know something about how @R{} objects are handled in
C code.  All the @R{} objects you will deal with will be handled with
the type @dfn{SEXP}@footnote{SEXP is an acronym for @emph{S}imple
@emph{EXP}ression, common in LISP-like language syntaxes.}, which is a
pointer to a structure.  Think of this structure as a @emph{variant
type} that can handle all the usual types of @R{} objects, that is
vectors of various modes, functions, environments, language objects and
so on.  The details are given later in this section, but for most
purposes the programmer does not need to know them.  Think rather of a
model such as that used by Visual Basic, in which @R{} objects are
handed around in C code (as they are in interpreted @R{} code) as the
variant type, and the appropriate part is extracted for, for example,
numerical calculations, only when it is needed.  As in interpreted @R{}
code, much use is made of coercion to force the variant object to the
right type.

@menu
* Garbage Collection::          
* Allocating storage::          
* Details of R types::          
* Attributes::                  
* Classes::                     
* Handling lists::              
* Finding and setting variables::  
@end menu

@node Garbage Collection, Allocating storage, Handling R objects in C, Handling R objects in C
@subsection Handling the effects of garbage collection
@cindex Handling the effects of garbage collection

@findex PROTECT
@findex UNPROTECT

We need to know a little about the way @R{} handles memory allocation.
The memory allocated for @R{} objects is not freed by the user; instead,
the memory is from time to time @dfn{garbage collected}.  That is, all
the allocated memory not being used is freed, and the objects that are
in use may be moved.  If you create an @R{} object in your C code, you
must tell @R{} that you are using the object via call to the
@code{PROTECT} macro.  This has two effects.  First it tells @R{} that
the object is in use so it is not destroyed.  Second, it ensures that
the @code{SEXP} pointer to the object is updated if the object's
structure is moved in memory during garbage collection.  (Because of
this it is not safe to save and re-use pointers to parts of an object's
structure.)

The programmer is solely responsible for housekeeping the calls to
@code{PROTECT}.  There is a corresponding macro @code{UNPROTECT} that
takes as argument an @code{int} giving the number of @code{SEXP}s to
unprotect when they are no longer needed.  The protection mechanism is
stack-based, so @code{UNPROTECT(n)} unprotects the last @code{n} objects
which were protected.  The calls to @code{PROTECT} and @code{UNPROTECT}
must balance when the user's code returns, even if it returns because of
an error (calling @code{error} or @code{errorcall} for example).  @R{}
will warn about @code{stack imbalance in .Call} (or @code{.External}) if
the housekeeping is wrong.

Here is a small example of creating an @R{} numeric vector in C code.
First we use the macros in @file{Rdefines.h}:

@example
#include <Rdefines.h>

  SEXP ab;
    ....
  PROTECT(ab = NEW_NUMERIC(2));
  NUMERIC_POINTER(ab)[0] = 123.45;
  NUMERIC_POINTER(ab)[1] = 67.89;
  UNPROTECT(1);
@end example

@noindent
and then those in @file{Rinternals.h}:

@example
#include <Rinternals.h>

  SEXP ab;
    ....
  PROTECT(ab = allocVector(REALSXP, 2));
  REAL(ab)[0] = 123.45; REAL(ab)[1] = 67.89;
  UNPROTECT(1);
@end example

Now, the reader may ask how the @R{} object could possibly get removed
during those manipulations, as it is just our C code that is running.
The answer is we do not know (nor want to know) what is hiding behind
the @R{} macros and functions we use, and any of them might cause memory
to be allocated, hence garbage collection and hence our object @code{ab}
to be (re)moved.  It is wise to err on the side of caution and assume
that any of the @R{} macros and functions might (re)move the object.

Protection is not needed for objects which @R{} already knows are in
use.  In particular, this applies to function arguments.

There is a less-used@footnote{for historical reasons,
@code{UNPROTECT_PTR(s)} has existed only since @R{} version 0.63.0 (Nov.@:
1998)} macro @code{UNPROTECT_PTR(s)} that unprotects the @code{SEXP} s.

@findex UNPROTECT_PTR

@node Allocating storage, Details of R types, Garbage Collection, Handling R objects in C
@subsection Allocating storage
@cindex Allocating storage

For many purposes it is sufficient to allocate @R{} objects and
manipulate those.  There are quite a few @code{allocXxx} functions
defined in @file{Rinternals.h} --- you may want to explore them.  These
allocate @R{} objects of various types, and for the standard vector
types there are @code{NEW_XXX} macros defined in @file{Rdefines.h}.

If storage is required for C objects during the calculations this is
best allocating by calling @code{R_alloc}; such storage is automatically
released once the call to @code{.C} or @code{.Call} or @code{.External}
returns.  @code{R_alloc} is defined in @file{Memory.h} (included by
@file{Rinternals.h} and by @file{Rdefines.h}) as

@example
char*  R_alloc(long, int);
@end example

@noindent
so a typical usage is

@example
v = (double*) R_alloc(nlag, sizeof(double));
@end example

Memory allocated by @code{R_alloc} is not zeroed, but the related
function @code{S_alloc} calls @code{R_alloc} and then zeroes the memory.

All of these memory allocation routines do their own error-checking, so
the programmer may assume that they will raise an error and not return
if the memory cannot be allocated.

@node Details of R types, Attributes, Allocating storage, Handling R objects in C
@subsection Details of R types
@cindex Details of R types

Users of the @file{Rinternals.h} macros will need to know how the @R{}
types are known internally: this is more or less completely hidden if
the @file{Rdefines.h} macros are used.

The different @R{} data types are represented in C by @dfn{SEXPTYPE}.
Some of these are familiar from @R{} and some are internal data types.
The usual @R{} object modes are given in the table.

@quotation
@multitable {SEXPTYPE} {numeric with storage mode integer integer}
@item @strong{SEXPTYPE} @tab @strong{@R{} equivalent / explanation}
@item @code{REALSXP}  @tab numeric with storage mode @code{double}
@item @code{INTSXP}   @tab integer
@item @code{CPLXSXP}  @tab complex
@item @code{LGLSXP}   @tab logical
@item @code{STRSXP}   @tab character
@item @code{VECSXP}   @tab list (generic vector)
@item @code{LISTXP}   @tab "dotted-pair" list
@item @code{DOTSXP}   @tab a @dots{} object
@item @code{NILSXP}   @tab NULL
@item @code{SYMSXP}   @tab name/symbol
@item @code{CLOSXP}   @tab function or function closure
@item @code{ENVSXP}   @tab environment
@end multitable
@end quotation
@noindent
Among the important internal @code{SEXPTYPE}s are @code{LANGSXP},
@code{CHARSXP} etc.

Unless you are very sure about the type of the arguments, the code
should check the data types.  Sometimes it may also be necessary to
check data types of objects created by evaluating an @R{} expression in
the C code.  You can use functions like @code{isReal}, @code{isInteger}
and @code{isString} to do type checking.  See the header file
@file{Rinternals.h} for definitions of other such functions.  All of
these take a @code{SEXP} as argument and return 1 or 0 to indicate
@var{TRUE} or @var{FALSE}.  Once again there are two ways to do this,
and @file{Rdefines.h} has macros such as @code{IS_NUMERIC}.

What happens if the @code{SEXP} is not of the correct type? Sometimes
you have no other option except to generate an error.  You can use the
function @code{error} for this.  It is usually better to coerce the
object to the correct type.  For example, if you find that an
@code{SEXP} is of the type @code{INTEGER}, but you need a @code{REAL}
object, you can change the type by using, equivalently,

@example
PROTECT(@var{newSexp} = coerceVector(@var{oldSexp}, REALSXP));
@end example

@noindent
or

@example
PROTECT(@var{newSexp} = AS_NUMERIC(@var{oldSexp}));
@end example

@noindent
Protection is needed as a new @emph{object} is created; the object
formerly pointed to by the @code{SEXP} is re-used is still protected but
now unused.

All the coercion functions do their own error-checking, and generate
@code{NA}s with a warning or stop with an error as appropriate.

So far we have only seen how to create and coerce @R{} objects from C
code, and how to extract the numeric data from numeric @R{} vectors.
These can suffice to take us a long way in interfacing @R{} objects to
numerical algorithms, but we may need to know a little more to create
useful return objects.

@node Attributes, Classes, Details of R types, Handling R objects in C
@subsection Attributes
@cindex Attributes

Many @R{} objects have attributes: some of the most useful are classes
and the @code{dim} and @code{dimnames} that mark objects as matrices or
arrays.  It can also be helpful to work with the @code{names} attribute
of vectors.

To illustrate this, let us write code to take the outer product of two
vectors (which @code{outer} and @code{%o%} already do).  As usual the
@R{} code is simple

@example
out <- function(x, y) .Call("out", as.double(x), as.double(y))
@end example

@noindent
where we expect @code{x} and @code{y} to be numeric vectors, possibly
with names.  This time we do the coercion in the calling @R{} code.
@*
C code to do the computations is

@example
#include <Rinternals.h>

SEXP out(SEXP x, SEXP y)
@{
  int i, j, nx, ny;
  double tmp;
  SEXP ans;

  nx = length(x); ny = length(y);
  PROTECT(ans = allocMatrix(REALSXP, nx, ny));
  for(i = 0; i < nx; i++) @{
    tmp = REAL(x)[i];
    for(j = 0; j < ny; j++)
      REAL(ans)[i + nx*j] = tmp * REAL(y)[j];
  @}
  UNPROTECT(1);
  return(ans);
@}
@end example

@noindent
but we would like to set the @code{dimnames} of the result.  Although
@code{allocMatrix} provides a short cut, we will show how to set the
@code{dim} attribute directly.

@example
#include <Rinternals.h>

SEXP out(SEXP x, SEXP y)
@{
  int i, j, nx, ny;
  double tmp;
  SEXP ans, dim, dimnames;

  nx = length(x); ny = length(y);
  PROTECT(ans = allocVector(nx*ny, REALSXP));
  for(i = 0; i < nx; i++) @{
    tmp = REAL(x)[i];
    for(j = 0; j < ny; j++)
      REAL(ans)[i + nx*j] = tmp * REAL(y)[j];
  @}
  PROTECT(dim = allocVector(INTSXP, 2));
  INTEGER(dim)[0] = nx; INTEGER(dim)[1] = ny;
  setAttrib(ans, R_DimSymbol, dim);

  PROTECT(dimnames = allocVector(VECSXP, 2));
  VECTOR(dimnames)[0] = getAttrib(x, R_NamesSymbol);
  VECTOR(dimnames)[1] = getAttrib(y, R_NamesSymbol);
  setAttrib(ans, R_DimNamesSymbol, dimnames);
  UNPROTECT(3);
  return(ans);
@}
@end example

This example introduces several new features.  The @code{getAttrib} and
@code{setAttrib} functions get and set individual attributes.  Their
second argument is a @code{SEXP} defining the name in the symbol table
of the attribute we want; these and many such symbols are defined in the
header file @file{Rinternals.h}.

There are shortcuts here too: the functions @code{namesgets},
@code{dimgets} and @code{dimnamesgets} are the internal versions of
@code{names<-}, @code{dim<-} and @code{dimnames<-}, and there are
functions such as @code{GetMatrixDimnames} and @code{GetArrayDimnames}.

What happens if we want to add an attribute that is not pre-defined? We
need to add a symbol for it @emph{via} a call to @code{install}.
Suppose for illustration we wanted to add an attribute @code{"version"}
with value @code{3.0}.  We could use

@example
  @{ SEXP version;
  PROTECT(version = allocVector(REALSXP, 1));
  REAL(vector) = 3.0;
  setAttrib(ans, install("version"), version);
  UNPROTECT(1);
  @}
@end example

Using @code{install} when it is not needed is harmless and provides a
simple way to retrieve the symbol from the symbol table if it is already
installed.

@node Classes, Handling lists, Attributes, Handling R objects in C
@subsection Classes
@cindex Classes

In @R{} the class is just the attribute named @code{"class"} so it can
be handled as such, but there is a shortcut @code{classgets}.  Suppose
we want to give the return value in our example the class @code{"mat"}.
We can use

@example
#include <Rdefines.h>
    ....
  SEXP ans, dim, dimnames, class;
    ....
  PROTECT(class = allocVector(STRSXP, 1));
  STRING(class)[0] = COPY_TO_USER_STRING("mat");
  classgets(ans, class);
  UNPROTECT(4);
  return(ans);
@}
@end example

@noindent
As the value is a character vector, we have to know how to create that
from a C character array, which we do using the macro
@code{COPY_TO_USER_STRING} defined in @file{Rdefines.h}.

@node Handling lists, Finding and setting variables, Classes, Handling R objects in C
@subsection Handling lists
@cindex Handling lists

Some care is needed with lists, as @R{} has moved from using LISP-like
lists (now called `pairlists') to S-like generic vectors.  As a result,
the appropriate test for a object of mode @code{list} is
@code{isNewList}, and we need @code{allocVector(VECSXP, n}) and
@emph{not} @code{allocList(n)}.

List elements can be retrieved or set by direct access to the elements
of the generic vector.  Suppose we have a list object

@example
a <- list(f=1, g=2, h=3)
@end example

@noindent
Then we can access @code{a$g} as @code{a[[2]]} by

@example
  double g;
    ....
  g = REAL(VECTOR(a)[1])[0];
@end example

This can rapidly become tedious, and the following function (based on
one in package @code{nls}) is very useful:

@example
/* get the list element named str, or return NULL */

SEXP getListElement(SEXP list, char *str)
@{
  SEXP elmt = R_NilValue, names = getAttrib(list, R_NamesSymbol);
  int i;

  for (i = 0; i < length(list); i++)
    if(strcmp(CHAR(STRING(names)[i]), str) == 0) @{
      elmt = VECTOR(list)[i];
      break;
    @}
  return elmt;
@}
@end example
@noindent
and enables us to say
@example
  double g;
  g = REAL(getListElement(a, "g"))[0];
@end example
@noindent

@node Finding and setting variables,  , Handling lists, Handling R objects in C
@subsection Finding and setting variables
@cindex Finding and setting variables

It will be usual that all the @R{} objects needed in our C computations
are passed as arguments to @code{.Call} or @code{.External}, but it is
possible to find the values of @R{} objects from within the C given
their names.  The following code is the equivalent of @code{get(name,
envir = rho)}.

@example
SEXP getvar(SEXP name, SEXP rho)
@{
  SEXP ans;

  if(!isString(name) || length(name) != 1)
     error("name is not a single string");
  if(!isEnvironment(rho))
    error("rho should be an environment");
  ans = findVar(install(CHAR(STRING(name)[0])), rho);
  printf("first value is %f\n", REAL(ans)[0]);
  return(R_NilValue);
@}
@end example

The main work is done by @code{findVar}, but to use it we need to
install @code{name} as a name in the symbol table.  As we wanted the
value for internal use, we return @code{NULL}.

Similar functions with syntax

@example
void defineVar(SEXP symbol, SEXP value, SEXP rho)
void setVar(SEXP symbol, SEXP value, SEXP rho)
@end example

@noindent
can be used to assign values to @R{} objects, in the specified
environment frame and to perform the equivalent of @code{assign(x,
value, envir = rho, inherits = TRUE)} respectively.

@node Interface Functions .Call and .External, Evaluating R Expressions from C, Handling R objects in C, System and foreign language interfaces
@section Interface Functions @code{.Call} and @code{.External}

In this section we consider the details of the @R{}/C interfaces.

These two interfaces have almost the same functionality. @code{.Call} is
based on the interface of the same name in S version 4, and
@code{.External} is based on @code{.Internal}.  @code{.External} is more
complex but allows a variable number of arguments.


@menu
* Calling .Call::               
* Calling .External::           
* Missing and special values::  
@end menu

@node Calling .Call, Calling .External, Interface Functions .Call and .External, Interface Functions .Call and .External
@subsection Calling @code{.Call}

@findex .Call

Let us convert our finite convolution example to use @code{.Call}, first
using the @file{Rdefines.h} macros.  The calling function in @R{} is

@example
conv <- function(a, b) .Call("convolve2", a, b)
@end example

@noindent
which could hardly be simpler, but as we shall see all the type checking
must be transferred to the C code, which is

@example
#include <S.h>

SEXP convolve2(SEXP a, SEXP b)
@{
  int i, j, na, nb, nab;
  double *xa, *xb, *xab;
  SEXP ab;

  PROTECT(a = AS_NUMERIC(a)); 
  PROTECT(b = AS_NUMERIC(b));
  na = LENGTH(a); nb = LENGTH(b); nab = na + nb - 1;
  PROTECT(ab = NEW_NUMERIC(nab));
  xa = NUMERIC_POINTER(a); xb = NUMERIC_POINTER(b);
  xab = NUMERIC_POINTER(ab);
  for(i = 0; i < nab; i++) xab[i] = 0.0;
  for(i = 0; i < na; i++)
    for(j = 0; j < nb; j++) xab[i + j] += xa[i] * xb[j];
  UNPROTECT(3);
  return(ab);
@}
@end example

Note that unlike the macros in S version 4, the @R{} versions of these
macros do check that coercion can be done and raise an error if it
fails.  They will raise warnings if missing values are introduced by
coercion. Although we illustrate doing the coercion in the C code here,
it often is simpler to do the necessary coercions in the @R{} code.

Now for the version in @R{}-internal style.  Only the C code changes.

@example
#include <Rinternals.h>

SEXP convolve2(SEXP a, SEXP b)
@{
  int i, j, na, nb, nab;
  double *xa, *xb, *xab;
  SEXP ab;

  PROTECT(a = coerceVector(a, REALSXP));
  PROTECT(b = coerceVector(b, REALSXP));
  na = length(a); nb = length(b); nab = na + nb - 1;
  PROTECT(ab = allocVector(nab, REALSXP));
  xa = REAL(a); xb = REAL(b);
  xab = REAL(ab);
  for(i = 0; i < nab; i++) xab[i] = 0.0;
  for(i = 0; i < na; i++)
    for(j = 0; j < nb; j++) xab[i + j] += xa[i] * xb[j];
  UNPROTECT(3);
  return(ab);
@}
@end example

@noindent
This is called in exactly the same way.

@node Calling .External, Missing and special values, Calling .Call, Interface Functions .Call and .External
@subsection Calling @code{.External}

@findex .External

We can use the same example to illustrate @code{.External}.  The @R{}
code changes only by replacing @code{.Call} by @code{.External}

@example
conv <- function(a, b) .External("convolveE", a, b)
@end example

@noindent
but the main change is how the arguments are passed to the C code, this
time as a single SEXP.  The only change to the C code is how we handle
the arguments.

@example
#include <Rinternals.h>

SEXP convolveE(SEXP args)
@{
  int i, j, na, nb, nab;
  double *xa, *xb, *xab;
  SEXP a, b, ab;

  PROTECT(a = coerceVector(CADR(args), REALSXP)));
  PROTECT(b = coerceVector(CADDR(args), REALSXP)));
    ...
@}
@end example

@noindent
Once again we do not need to protect the arguments, as in the @R{} side
of the interface they are objects that are already in use.  The macros

@example
  first = CADR(args);
  second = CADDR(args);
  third = CADDDR(args);
  fourth = CAD4R(args);
@end example

@noindent
provide convenient ways to access the first four arguments.  More
generally we can use the @code{CDR} and @code{CAR} macros as in

@example
  args = CDR(args); a = CAR(args);
  args = CDR(args); b = CAR(args);
@end example

@noindent
which clearly allows us to extract an unlimited number of arguments
(whereas @code{.Call} has a limit, albeit at 65 not a small one).

More usefully, the @code{.External} interface provides an easy way to
handle calls with a variable number of arguments, as @code{length(args)}
will give the number of arguments supplied (of which the first is
ignored).  We may need to know the names (`tags') given to the actual
arguments, which we can by using the @code{TAG} macro and using
something like the following example, that print the names and the first
value of its arguments if they are vector types.

@example
SEXP showArgs(SEXP args)
@{
  int i, nargs;
  Rcomplex cpl;
  char *name;

  if((nargs = length(args) - 1) > 0) @{
    for(i = 0; i < nargs; i++) @{
      args = CDR(args);
      name = CHAR(PRINTNAME(TAG(args)));
      switch(TYPEOF(CAR(args))) @{
      case REALSXP:
        printf("[%d] '%s' %f\n", i+1, name, REAL(CAR(args))[0]);
      break;
      case LGLSXP:
      case INTSXP:
        printf("[%d] '%s' %d\n", i+1, name, INTEGER(CAR(args))[0]);
      break;
      case CPLXSXP:
        cpl = COMPLEX(CAR(args))[0];
        printf("[%d] '%s' %f + %fi\n", i+1, name, cpl.r, cpl.i);
        break;
      case STRSXP:
        printf("[%d] '%s' %s\n", i+1, name,
               CHAR(STRING(CAR(args))[0]));
        break;
      default:
        printf("[%d] '%s' R type\n", i+1, name);
      @}
    @}
  @}
  return(R_NilValue);
@}
@end example

This can be called by the wrapper function

@example
showArgs <- function(...) .External("showArgs", ...)
@end example

@noindent
Note that this style of programming is convenient but not necessary, as
an alternative style is

@example
showArgs <- function(...) .Call("showArgs1", list(...))
@end example

@node Missing and special values,  , Calling .External, Interface Functions .Call and .External
@subsection Missing and special values

One piece of error-checking the @code{.C} call does (unless @code{NAOK}
is true) is to check for missing (@code{NA}) and IEEE special values
(@code{Inf}, @code{-Inf} and @code{NaN}) and give an error if any are
found.  With the @code{.Call} interface these will be passed to our
code.  In this example the special values are no problem, as IEEE
arithmetic will handle them correctly.  In the current implementation
this is also true of @code{NA} as it is a type of @code{NaN}, but it is
unwise to rely on such details.  Thus we will re-write the code to
handle @code{NA}s using macros defined in @file{Arith.h}.

The code changes are the same in any of the versions of @code{convolve2}
or @code{convolveE}:
@example
    ...
  for(i = 0; i < na; i++)
    for(j = 0; j < nb; j++)
        if(ISNA(xa[i]) || ISNA(xb[j]) || ISNA(xab[i + j]))
          xab[i + j] = NA_REAL;
        else
          xab[i + j] += xa[i] * xb[j];
    ...
@end example

Note that the @code{ISNA} macro, and the similar macros @code{ISNAN}
(which checks for @code{NaN} or @code{NA}) and @code{R_FINITE} (which is
false for @code{NA} and all the special values), only apply to numeric
values of type @code{double}.  Missingness of integers, logicals and
character strings can be tested by equality to the constants
@code{NA_INTEGER}, @code{NA_LOGICAL} and @code{NA_STRING}.  These and
@code{NA_REAL} can be used to set elements of @R{} vectors to @code{NA}.

The constants @code{R_NaN}, @code{R_PosInf}, @code{R_NegInf} and
@code{R_NaReal} can be used to set @code{double}s to the special values.

@node Evaluating R Expressions from C,  , Interface Functions .Call and .External, System and foreign language interfaces
@section Evaluating R Expressions from C

We noted that the @code{call_R} interface could be
used to evaluate @R{} expressions from C code, but the current
interfaces are much more convenient to use.  The main function we will
use is

@example
SEXP eval(SEXP expr, SEXP rho);
@end example

@noindent
the equivalent of the interpreted @R{} code @code{eval(expr, envir =
rho)}, although we can also make use of @code{findVar}, @code{defineVar}
and @code{findFun} (which restricts the search to functions).

To see how this might be applied, here is a simplified internal version
of @code{lapply} for expressions, used as

@example
a <- list(a = 1:5, b = rnorm(10), test = runif(100))
.Call("lapply", a, quote(sum(x)), new.env())
@end example

@noindent
with C code

@example
SEXP lapply(SEXP list, SEXP expr, SEXP rho)
@{
  int i, n = length(list);
  SEXP ans;

  if(!isNewList(list)) error("`list' must be a list");
  if(!isEnvironment(rho)) error("`rho' should be an environment");
  PROTECT(ans = allocVector(VECSXP, n));
  for(i = 0; i < n; i++) @{
    defineVar(install("x"), VECTOR(list)[i], rho);
    VECTOR(ans)[i] = eval(expr, rho);
  @}
  setAttrib(ans, R_NamesSymbol, getAttrib(list, R_NamesSymbol));
  UNPROTECT(1);
  return(ans);
@}
@end example

It would be closer to @code{lapply} if we could pass in a function
rather than an expression.  One way to do this is @emph{via} interpreted
@R{} code as in the next example, but it is possible (if somewhat
obscure) to do this in C code.  The following is based on the code in
@file{src/main/optimize.c}.

@example
SEXP lapply2(SEXP list, SEXP expr, SEXP rho)
@{
  int i, n = length(list);
  SEXP R_fcall, s, ans;

  if(!isNewList(list)) error("`list' must be a list");
  if(!isFunction(fn)) error("`fn' must be a function");
  if(!isEnvironment(rho)) error("`rho' should be an environment");
  PROTECT(R_fcall = lang2(fn, R_NilValue));
  PROTECT(ans = allocVector(VECSXP, n));
  for(i = 0; i < n; i++) @{
    CADR(R_fcall) = VECTOR(list)[i];
    VECTOR(ans)[i] = eval(expr, rho);
  @}
  setAttrib(ans, R_NamesSymbol, getAttrib(list, R_NamesSymbol));
  UNPROTECT(1);
  return(ans);
@}
@end example

@noindent
used by

@example
.Call("lapply2", a, sum, new.env())
@end example

@noindent
Function @code{lang2} creates an executable `list' of two elements, but
this will only be clear to those with a knowledge of a LISP-like
language.

@subsection Zero-finding

In this section we re-work the example in @file{demos/dynload} of
@code{call_R} (based on that for @code{call_S} in Becker, Chambers &
Wilks (1988)) on finding a zero of a univariate function.  The @R{} code
and an example are

@example
zero <- function(f, guesses, tol = 1e-7) @{
  f.check <- function(x) @{
    x <- f(x)
    if(!is.numeric(x)) stop("Need a numeric result")
    as.double(x)
  @}
  .Call("zero", body(f.check), as.double(guesses), as.double(tol),
        new.env())
@}

cube1 <- function(x) (x^2 + 1) * (x - 1.5)
zero(cube1, c(0, 5))
@end example

@noindent
where this time we do the coercion and error-checking in the @R{} code.
The C code is

@example
SEXP mkans(double x)
@{
    SEXP ans;
    PROTECT(ans = allocVector(REALSXP, 1));
    REAL(ans)[0] = x;
    UNPROTECT(1);
    return ans;
@}

double feval(double x, SEXP f, SEXP rho)
@{
    defineVar(install("x"), mkans(x), rho);
    return(REAL(eval(f, rho))[0]);
@}

SEXP zero(SEXP f, SEXP guesses, SEXP stol, SEXP rho)
@{
    double x0 = REAL(guesses)[0], x1 = REAL(guesses)[1],
           tol = REAL(stol)[0];
    double f0, f1, fc, xc;
    SEXP res;

    if(tol <= 0.0) error("non-positive tol value");
    f0 = feval(x0, f, rho); f1 = feval(x1, f, rho);
    if(f0 == 0.0) return mkans(x0);
    if(f1 == 0.0) return mkans(x1);
    if(f0*f1 > 0.0) error("x[0] and x[1] have the same sign");
    for(;;) @{
        xc = 0.5*(x0+x1);
        if(fabs(x0-x1) < tol) return  mkans(xc);
        fc = feval(xc, f, rho);
        if(fc == 0) return  mkans(xc);
        if(f0*fc > 0.0) @{
            x0 = xc; f0 = fc;
        @} else @{
            x1 = xc; f1 = fc;
        @}
    @}
@}
@end example

@noindent
The C code is essentially unchanged for the @code{call_R} version, just
using a couple of functions to convert from @code{double} to @code{SEXP}
and to evaluate @code{f.check}.

@subsection Calculating numerical derivatives

We will use a longer example (by Saikat DebRoy) to illustrate the use of
evaluation and @code{.External}.  This calculates numerical derivatives,
something that could be done as effectively in interpreted @R{} code but
may be needed as part of a larger C calculation.

An interpreted @R{} version and an example are

@example
numeric.deriv <- function(expr, theta, rho=sys.frame(sys.parent()))
@{
  eps <- sqrt(.Machine$double.eps)
  ans <- eval(substitute(expr), rho)
  grad <- matrix(,length(ans), length(theta),
                 dimnames=list(NULL, theta))
  for (i in seq(along=theta)) @{
    old <- get(theta[i], envir=rho)
    delta <- eps * min(1, abs(old))
    assign(theta[i], old+delta, envir=rho)
    ans1 <- eval(substitute(expr), rho)
    assign(theta[i], old, envir=rho)
    grad[, i] <- (ans1 - ans)/delta
  @}
  attr(ans, "gradient") <- grad
  ans
@}
omega <- 1:5; x <- 1; y <- 2
numeric.deriv(sin(omega*x*y), c("x", "y"))
@end example

@noindent
where @code{expr} is an expression, @code{theta} a character vector of
variable names and @code{rho} the environment to be used.

For the compiled version the call from @R{} will be

@example
.External("numeric_deriv", @var{expr}, @var{theta}, @var{rho})
@end example

@noindent
with example usage

@example
.External("numeric_deriv", quote(sin(omega*x*y)),
          c("x", "y"), .GlobalEnv)
@end example

@noindent
Note the need to quote the expression to stop it being evaluated.

Here is the complete C code which we will explain section by section.
@example
#include <S.h> /* for DOUBLE_EPS */
#include <Rinternals.h>

SEXP numeric_deriv(SEXP args)
@{
  SEXP theta, expr, rho, ans, ans1, gradient, par, dimnames;
  double tt, xx, delta, eps = sqrt(DOUBLE_EPS);
  int start, i, j;

  expr = CADR(args);
  if(!isString(theta = CADDR(args)))
    error("theta should be of type character");
  if(!isEnvironment(rho = CADDR(args)))
    error("rho should be an environment");

  PROTECT(ans = coerceVector(eval(expr, rho), REALSXP));
  PROTECT(gradient = allocMatrix(REALSXP, LENGTH(ans), LENGTH(theta)));

  for(i = 0, start = 0; i < LENGTH(theta); i++, start += LENGTH(ans)) @{
    PROTECT(par = findVar(install(CHAR(STRING(theta)[i])), rho));
    tt = REAL(par)[0];
    xx = fabs(tt);
    delta = (xx < 1) ? eps : xx*eps;
    REAL(par)[0] += delta;
    PROTECT(ans1 = coerceVector(eval(expr, rho), REALSXP));
    for(j = 0; j < LENGTH(ans); j++)
      REAL(gradient)[j + start] =
        (REAL(ans1)[j] - REAL(ans)[j])/delta;
    REAL(par)[0] = tt;
    UNPROTECT(2); /* par, ans1 */
  @}

  PROTECT(dimnames = allocVector(VECSXP, 2));
  VECTOR(dimnames)[1] = theta;
  dimnamesgets(gradient, dimnames);
  setAttrib(ans, install("gradient"), gradient);
  UNPROTECT(3); /* ans  gradient  dimnames */
  return ans;
@}
@end example

The code to handle the arguments is

@example
  expr = CADR(args);
  if(!isString(theta = CADDR(args)))
    error("theta should be of type character");
  if(!isEnvironment(rho = CADDR(args)))
    error("rho should be an environment");
@end example

@noindent
Note that we check for correct types of @code{theta} and @code{rho} but
do not check the type of @code{expr}.  That is because @code{eval} can
handle many types of @R{} objects other than @code{EXPRSXP}.  There is
no useful coercion we can do, so we stop with an error message if the
arguments are not of the correct mode.

The first step in the code is to evaluate the expression in the
environment @code{rho}, by

@example
  PROTECT(ans = eval(expr, rho));
@end example

@noindent
We then allocate space for the calculated derivative by

@example
  PROTECT(gradient = allocMatrix(REALSXP, LENGTH(ans), LENGTH(theta)));
@end example

@noindent
The first argument to @code{allocMatrix} gives the @code{SEXPTYPE} of
the matrix: here we want it to be @code{REALSXP}.  The other two
arguments are the numbers of rows and columns.

@example
  for(i = 0, start = 0; i < LENGTH(theta); i++, start += LENGTH(ans)) @{
    PROTECT(par = findVar(install(CHAR(STRING(theta)[i])), rho));
@end example

@noindent
Here, we are entering a for loop.  We loop through each of the
variables.  In the @code{for} loop, we first create a symbol
corresponding to the @code{i}'th element of the @code{STRSXP}
@code{theta}.  Here, @code{STRING(theta)[i]} accesses the @code{i}'th
element of the @code{STRSXP} @code{theta}.  Macro @code{CHAR()} extracts
the actual character representation of it: it returns a pointer.  We
then install the name and use @code{findVar} to find its value.

@example
    tt = REAL(par)[0];
    xx = fabs(tt);
    delta = (xx < 1) ? eps : xx*eps;
    REAL(par)[0] += delta;
    PROTECT(ans1 = eval(expr, rho));  /* not currently needed */
@end example

@noindent
We first extract the real value of the parameter, then calculate delta,
the increment to be used for approximating the numerical derivative.
Then we change the value stored in @code{par} (in environment
@code{rho}) by @code{delta} and evaluate @code{expr} in environment
@code{rho} again.  Because we are directly dealing with original @R{}
memory locations here, @R{} does the evaluation for the changed
parameter value.

@example
    for(j = 0; j < LENGTH(ans); j++)
      REAL(gradient)[j + start] =
        (REAL(ans1)[j] - REAL(ans)[j])/delta;
    REAL(par)[0] = tt;
    UNPROTECT(2);
  @}
@end example

@noindent
Now, we compute the @code{i}'th column of the gradient matrix.  Note how
it is accessed: @R{} stores matrices by column (like Fortran).

@example
  PROTECT(dimnames = allocVector(VECSXP, 2));
  VECTOR(dimnames)[1] = theta;
  dimnamesgets(gradient, dimnames);
  setAttrib(ans, install("gradient"), gradient);
  UNPROTECT(3);
  return ans;
@}
@end example

@noindent
First we add column names to the gradient matrix.  This is done by
allocating a list (a @code{VECSXP}) whose first element, the row names,
is @code{NULL} (the default) and the second element, the column names,
is set as @code{theta}.  This list is then assigned as the attribute
having the symbol @code{R_DimNamesSymbol}.  Finally we set the gradient
matrix as the gradient attribute of @code{ans}, unprotect the remaining
protected locations and return the answer @code{ans}.

@node R (internal) programming miscellania, Function and variable index, System and foreign language interfaces, Top
@appendix R (internal) programming miscellania

@menu
* Which R functions should stay @sc{<primitive>}?::  
@end menu

@findex .Internal
@findex .Primitive

@node Which R functions should stay @sc{<primitive>}?,  , R (internal) programming miscellania, R (internal) programming miscellania
@section Which R functions should stay @sc{<primitive>}?

In general, all functions should be written using @code{.Internal()}.
However, there are exceptions which are fully specified as follows:

@enumerate

@item
``Special functions'' which really are @emph{language} elements, however
exist as @sc{<primitive>}s in @R{}:

@example
@{       (         if       for  while  repeat  break  next
return  function  on.exit
@end example

@item
Basic @emph{operator}s (i.e., functions usually @emph{not} called as
@code{foo(a, b, ...)}) for subsetting, assignment, arithmetic and logic.
These are the following 1-, 2-, and @emph{N}-argument functions:

@example
          [    [[    $
<-   <<-  [<-  [[<-  $<-
---------------------------------------
+    -    *    /     ^    %%   %*%  %/%
<    <=   ==   !=    >=   >    \\
|    ||   &    &&    !
@end example

@item
``Low level'' 0- and 1-argument functions shall remain @sc{<primitive>},
iff they belong to one of the following groups of functions:

@enumerate a
@item
Basic mathematical functions with a single argument, i.e.,

@example
sign    abs
floor   ceiling
----------------------
sqrt    exp
cos     sin      tan
acos    asin     atan
cosh    sinh     tanh
acosh   asinh    atanh
----------------------
cumsum  cumprod
cummax  cummin
----------------------
Im      Re
Arg     Conj     Mod
@end example

@noindent Note that @code{log} has @emph{two} arguments, and we will
use

@example
log <- function(x, base = exp(1)) @{
  if(missing(base))
    .Internal(log(x))
  else
    .Internal(log(x, base))
@}
@end example

@noindent in order to ensure that @code{log(x = pi, base = 2)} is
identical to @code{log(base = 2, x = pi)}.

@item
Functions rarely used outside of ``programming'' (i.e., mostly used
inside other functions), such as

@example
nargs        missing
interactive  is.@emph{xxx}
.Primitive   .Internal   .External
symbol.C     symbol.For
globalenv    pos.to.env  unclass
@end example

@noindent
(where @emph{xxx} stands for almost 30 different notions, such as
@code{function}, @code{vector}, @code{numeric}, and so forth).

@item
The programming and session management utilities

@example
debug    undebug    trace  untrace
browser  proc.time
@end example

@end enumerate

@item
The following basic assignment and extractor functions

@example
.Alias      environment<-
length      length<-
class       class<-
attr        attr<-
attributes  attributes<-
dim         dim<-
dimnames    dimnames<-
@end example

@item
A few other @emph{N}-argument functions shall also remain
@sc{<primitive>}, for efficiency reasons.  Care is taken in order to
treat named arguments properly:

@example
:          ~          c           list        unlist
call       as.call    expression  substitute
UseMethod  invisible 
.C         .Fortran   .Call
@end example

@end enumerate

@node Function and variable index, Concept index, R (internal) programming miscellania, Top
@unnumbered Function and variable index

@printindex vr

@node Concept index,  , Function and variable index, Top
@unnumbered Concept index

@printindex cp

@bye

@c Local Variables: ***
@c mode: TeXinfo ***
@c End: ***
