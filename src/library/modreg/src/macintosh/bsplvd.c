/* bsplvd.f -- translated by f2c (version 19971204).   You must link the resulting object file with the libraries:	-lf2c -lm   (in that order)*/#include "f2c.h"/* Table of constant values */static integer c__1 = 1;static integer c__2 = 2;/* Subroutine */ int bsplvd(doublereal *t, integer *lent, integer *k, 	doublereal *x, integer *left, doublereal *a, doublereal *dbiatx, 	integer *nderiv){    /* System generated locals */    integer dbiatx_dim1, dbiatx_offset, a_dim1, a_offset, i__1, i__2, i__3;    /* Local variables */    static integer jlow, kp1mm, i__, j, m, mhigh, jp1mid;    static doublereal fkp1mm;    static integer il;    static doublereal factor;    static integer ideriv;    extern /* Subroutine */ int bsplvb(doublereal *, integer *, integer *, 	    integer *, doublereal *, integer *, doublereal *);    static integer ldummy, kp1;    static doublereal sum;/*     --------   ------ *//* calculates value and deriv.s of all b-splines which do not vanish at x *//* calls bsplvb *//* ******  i n p u t  ****** *//*  t     the knot array, of length left+k (at least) *//*  k     the order of the b-splines to be evaluated *//*  x     the point at which these values are sought *//*  left  an integer indicating the left endpoint of the interval of *//*        interest. the  k  b-splines whose support contains the interval *//*               (t(left), t(left+1)) *//*        are to be considered. *//*  a s s u m p t i o n  - - -  it is assumed that *//*               t(left) .lt. t(left+1) *//*        division by zero will result otherwise (in  b s p l v b ). *//*        also, the output is as advertised only if *//*               t(left) .le. x .le. t(left+1) . *//*  nderiv   an integer indicating that values of b-splines and their *//*        derivatives up to but not including the  nderiv-th  are asked *//*        for. ( nderiv  is replaced internally by the integer in (1,k) *//*        closest to it.) *//* ******  w o r k   a r e a  ****** *//*  a     an array of order (k,k), to contain b-coeff.s of the derivat- *//*        ives of a certain order of the  k  b-splines of interest. *//* ******  o u t p u t  ****** *//*  dbiatx   an array of order (k,nderiv). its entry  (i,m)  contains *//*        value of  (m-1)st  derivative of  (left-k+i)-th  b-spline of *//*        order  k  for knot sequence  t , i=m,...,k; m=1,...,nderiv. *//* ******  m e t h o d  ****** *//*  values at  x  of all the relevant b-splines of order k,k-1,..., *//*  k+1-nderiv  are generated via  bsplvb  and stored temporarily *//*  in  dbiatx .  then, the b-coeffs of the required derivatives of the *//*  b-splines of interest are generated by differencing, each from the *//*  preceding one of lower order, and combined with the values of b- *//*  splines of corresponding order in  dbiatx  to produce the desired *//*  values. *//* Args *//* Locals */    /* Parameter adjustments */    --t;    a_dim1 = *k;    a_offset = a_dim1 + 1;    a -= a_offset;    dbiatx_dim1 = *k;    dbiatx_offset = dbiatx_dim1 + 1;    dbiatx -= dbiatx_offset;    /* Function Body *//* Computing MAX */    i__1 = min(*nderiv,*k);    mhigh = max(i__1,1);/*     mhigh is usually equal to nderiv. */    kp1 = *k + 1;    i__1 = kp1 - mhigh;    bsplvb(&t[1], lent, &i__1, &c__1, x, left, &dbiatx[dbiatx_offset]);    if (mhigh == 1) {	goto L99;    }/*     the first column of  dbiatx  always contains the b-spline values *//*     for the current order. these are stored in column k+1-current *//*     order  before  bsplvb  is called to put values for the next *//*     higher order on top of it. */    ideriv = mhigh;    i__1 = mhigh;    for (m = 2; m <= i__1; ++m) {	jp1mid = 1;	i__2 = *k;	for (j = ideriv; j <= i__2; ++j) {	    dbiatx[j + ideriv * dbiatx_dim1] = dbiatx[jp1mid + dbiatx_dim1];/* L11: */	    ++jp1mid;	}	--ideriv;	i__2 = kp1 - ideriv;	bsplvb(&t[1], lent, &i__2, &c__2, x, left, &dbiatx[dbiatx_offset]);/* L15: */    }/*     at this point,  b(left-k+i, k+1-j)(x) is in  dbiatx(i,j) for *//*     i=j,...,k and j=1,...,mhigh ('=' nderiv). in particular, the *//*     first column of  dbiatx  is already in final form. to obtain cor- *//*     responding derivatives of b-splines in subsequent columns, gene- *//*     rate their b-repr. by differencing, then evaluate at  x. */    jlow = 1;    i__1 = *k;    for (i__ = 1; i__ <= i__1; ++i__) {	i__2 = *k;	for (j = jlow; j <= i__2; ++j) {/* L19: */	    a[j + i__ * a_dim1] = 0.f;	}	jlow = i__;/* L20: */	a[i__ + i__ * a_dim1] = 1.f;    }/*     at this point, a(.,j) contains the b-coeffs for the j-th of the *//*     k  b-splines of interest here. */    i__1 = mhigh;    for (m = 2; m <= i__1; ++m) {	kp1mm = kp1 - m;	fkp1mm = (doublereal) kp1mm;	il = *left;	i__ = *k;/*        for j=1,...,k, construct b-coeffs of  (m-1)st  derivative of *//*        b-splines from those for preceding derivative by differencing *//*        and store again in  a(.,j) . the fact that  a(i,j) = 0  for *//*        i .lt. j  is used.sed. */	i__2 = kp1mm;	for (ldummy = 1; ldummy <= i__2; ++ldummy) {	    factor = fkp1mm / (t[il + kp1mm] - t[il]);/*           the assumption that t(left).lt.t(left+1) makes denominator *//*           in  factor  nonzero. */	    i__3 = i__;	    for (j = 1; j <= i__3; ++j) {/* L24: */		a[i__ + j * a_dim1] = (a[i__ + j * a_dim1] - a[i__ - 1 + j * 			a_dim1]) * factor;	    }	    --il;/* L25: */	    --i__;	}/*        for i=1,...,k, combine b-coeffs a(.,i) with b-spline values *//*        stored in dbiatx(.,m) to get value of  (m-1)st  derivative of *//*        i-th b-spline (of interest here) at  x , and store in *//*        dbiatx(i,m). storage of this value over the value of a b-spline *//*        of order m there is safe since the remaining b-spline derivat- *//*        ive of the same order do not use this value due to the fact *//*        that  a(j,i) = 0  for j .lt. i . *//* L30: */	i__2 = *k;	for (i__ = 1; i__ <= i__2; ++i__) {	    sum = 0.f;	    jlow = max(i__,m);	    i__3 = *k;	    for (j = jlow; j <= i__3; ++j) {/* L35: */		sum = a[j + i__ * a_dim1] * dbiatx[j + m * dbiatx_dim1] + sum;	    }/* L40: */	    dbiatx[i__ + m * dbiatx_dim1] = sum;	}    }L99:    return 0;} /* bsplvd_ *//* Subroutine */ int bsplvb(doublereal *t, integer *lent, integer *jhigh, 	integer *index, doublereal *x, integer *left, doublereal *biatx){    /* Initialized data */    static integer j = 1;    /* System generated locals */    integer i__1;    /* Local variables */    static doublereal term;    static integer i__;    static doublereal saved, deltal[20], deltar[20];    static integer jp1;/*     ------------- *//* alculates the value of all possibly nonzero b-splines at  x  of order *//*               jout  =  dmax( jhigh , (j+1)*(index-1) ) *//*  with knot sequence  t . *//* ******  i n p u t  ****** *//*  t.....knot sequence, of length  left + jout  , assumed to be nonde- *//*        creasing.  a s s u m p t i o n . . . . *//*                       t(left)  .lt.  t(left + 1)   . *//*   d i v i s i o n  b y  z e r o  will result if  t(left) = t(left+1) *//*  jhigh, *//*  index.....integers which determine the order  jout = max(jhigh, *//*        (j+1)*(index-1))  of the b-splines whose values at  x  are to *//*        be returned.  index  is used to avoid recalculations when seve- *//*        ral columns of the triangular array of b-spline values are nee- *//*        ded (e.g., in  bvalue  or in  bsplvd ). precisely, *//*                     if  index = 1 , *//*        the calculation starts from scratch and the entire triangular *//*        array of b-spline values of orders 1,2,...,jhigh  is generated *//*        order by order , i.e., column by column . *//*                     if  index = 2 , *//*        only the b-spline values of order  j+1, j+2, ..., jout  are ge- *//*        nerated, the assumption being that  biatx , j , deltal , deltar *//*        are, on entry, as they were on exit at the previous call. *//*           in particular, if  jhigh = 0, then  jout = j+1, i.e., just *//*        the next column of b-spline values is generated. *//*  w a r n i n g . . .  the restriction   jout .le. jmax (= 20)  is im- *//*        posed arbitrarily by the dimension statement for  deltal  and *//*        deltar  below, but is  n o w h e r e  c h e c k e d  for . *//*  x.....the point at which the b-splines are to be evaluated. *//*  left.....an integer chosen (usually) so that *//*                  t(left) .le. x .le. t(left+1)  . *//* ******  o u t p u t  ****** *//*  biatx.....array of length  jout , with  biatx(i)  containing the val- *//*        ue at  x  of the polynomial of order  jout  which agrees with *//*        the b-spline  b(left-jout+i,jout,t)  on the interval (t(left), *//*        t(left+1)) . *//* ******  m e t h o d  ****** *//*  the recurrence relation *//*                       x - t(i)              t(i+j+1) - x *//*     b(i,j+1)(x)  =  -----------b(i,j)(x) + ---------------b(i+1,j)(x) *//*                     t(i+j)-t(i)            t(i+j+1)-t(i+1) *//*  is used (repeatedly) to generate the (j+1)-vector  b(left-j,j+1)(x), *//*  ...,b(left,j+1)(x)  from the j-vector  b(left-j+1,j)(x),..., *//*  b(left,j)(x), storing the new values in  biatx  over the old. the *//*  facts that *//*            b(i,1) = 1  if  t(i) .le. x .lt. t(i+1) *//*  and that *//*            b(i,j)(x) = 0  unless  t(i) .le. x .lt. t(i+j) *//*  are used. the particular organization of the calculations follows al- *//*  gorithm  (8)  in chapter x of the text. *//* Arguments *//*     dimension     t(left+jout), biatx(jout) *//*     ----------------------------------- *//* current fortran standard makes it impossible to specify the length of *//*  t  and of  biatx  precisely without the introduction of otherwise *//*  superfluous additional arguments. *//* Local Variables */    /* Parameter adjustments */    --t;    --biatx;    /* Function Body *//* (valid in fortran 77) */    switch (*index) {	case 1:  goto L10;	case 2:  goto L20;    }L10:    j = 1;    biatx[1] = 1.f;    if (j >= *jhigh) {	goto L99;    }L20:    jp1 = j + 1;    deltar[j - 1] = t[*left + j] - *x;    deltal[j - 1] = *x - t[*left + 1 - j];    saved = 0.f;    i__1 = j;    for (i__ = 1; i__ <= i__1; ++i__) {	term = biatx[i__] / (deltar[i__ - 1] + deltal[jp1 - i__ - 1]);	biatx[i__] = saved + deltar[i__ - 1] * term;/* L26: */	saved = deltal[jp1 - i__ - 1] * term;    }    biatx[jp1] = saved;    j = jp1;    if (j < *jhigh) {	goto L20;    }L99:    return 0;} /* bsplvb_ */